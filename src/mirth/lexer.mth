
import base/nat
import base/char
import base/list
import base/str
import base/regex+
import base/maybe
import mirth/types/mod
import mirth/loc
import mirth/token

isDecInt? : Str -- Str Bool
isDecInt? = and?(strnull? not, strall?(isdigit?))
isDecInt? drop == id
""           isDecInt? nip == false
"0"          isDecInt? nip == true
"1"          isDecInt? nip == true
"89"         isDecInt? nip == true
"3622614048" isDecInt? nip == true
"0098767890" isDecInt? nip == true
"1st"        isDecInt? nip == false

isHexInt? : Str -- Str Bool
isHexInt? = dup n2 strbreak and?(or?(over "0x" streq, over "0X" streq),
  and?(strnull? not, strall?(ishexdigit?))) dip(drop2)

isHexInt? drop == id
"0"    isHexInt? nip == false
"0x"   isHexInt? nip == false
"0xA"  isHexInt? nip == true
"0x0010"     isHexInt? nip == true
"0xdeadbeef" isHexInt? nip == true
"0xCABc4FED" isHexInt? nip == true
"0xFA12E8EX" isHexInt? nip == false
"0Xa0010aa0" isHexInt? nip == true
implies?(isDecInt?, "0x" over <> isHexInt? nip) == true

isIgnoreChar? : Char -- Char Bool
isIgnoreChar? = or?('\s' chareq? nip, or?('\t' chareq? nip, '\r' chareq? nip))
isIgnoreChar? drop == id

isCommentChar? : Char -- Char Bool
isCommentChar? = "#" str->char chareq? nip
isCommentChar? drop == id

breakComment : Str -- Str Str
breakComment = strbreakWhen ('\n' chareq? nip)

isInt? : Str -- Str Bool
isInt? = or? (isDecInt?, isHexInt?)


data LexerRule
  lexerRule(f: Str -- Token) : Regex -- LexerRule
end

readDecInt : Str -- Int
readHexInt : Str -- Int
readStr    : Str -- Str
wordToken  : Str -- Token  # basically TWORD but separates out reserved words.

lexerRules : List(LexerRule)
lexerRules = $(
  nil

  # ints
  "0123456789" cls plus lexerRule(readDecInt TINT) cons
  "0" lit "xX" cls "0123456789abcdefABCDEF" cls plus seq3 lexerRule(readHexInt TINT) cons

  # strings
  # TODO

  # words -- we use wordToken to disambiguate between reserved words and regular words.
  # TODO
)

data LexerMatch
  lexerMatch(f: Str -- Token) : Maybe(Nat) -- LexerMatch
end

lexerMatchUnwrap : LexerMatch -- Maybe(Nat)
lexerMatchUnwrap = match( lexerMatch(f) -> id )

lexerMatchCmp? : LexerMatch LexerMatch -- LexerMatch LexerMatch Comp
lexerMatchCmp? = dup2 both(lexerMatchUnwrap) mcmp(ncmp)

bestLexerMatch : Str -- LexerMatch
bestLexerMatch =
  lexerRules formap(
    match( lexerRule(f) ->
      dip(dup) regexMatch lexerMatch(f)
    )
  ) nip maximum(lexerMatchCmp?)

data LexerError
  lexerError : Loc Str -- LexerError
end

unLexerError : LexerError -- Loc Str
unLexerError = match( lexerError -> id )

lexerError->str : LexerError -- Str
lexerError->str = unLexerError dip(loc->str ":" <>) <>

data LexerState
  lexerState : Loc Str -- LexerState
end

unLexerState : LexerState -- Loc Str
unLexerState = match( lexerState -> id )



