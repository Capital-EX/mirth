import base/result
import base/map
import base/list
import base/sexp

import mirth/mod
import mirth/loc

export mirth/core
  type L(t)
  type Result(e,v)
  type Sexp

  type CoreError
  type CoreModule
  type CoreStmt
  type CoreCtx
  type CoreSym

  coreNil   : Mod -- CoreModule
  coreCons  : CoreModule L(CoreStmt) -- Result(CoreError, CoreModule)
  core->str : CoreModule -- Str
  core->sexp : CoreModule -- Sexp

  stmtTypeSig : CoreSym CoreCtx -- CoreStmt

  sym->str : CoreSym -- Str
end

data CoreCtx
  mkCtx : CoreCtx
end

ctx->sexp : CoreCtx -- Sexp
ctx->sexp = drop nil sexpList

data CoreStmt
  stmtTypeSig : CoreSym CoreCtx -- CoreStmt
end

data CoreDef
  defTypeSig : LocSet CoreCtx -- CoreDef
end

stmt->def : L(CoreStmt) -- CoreSym CoreDef
stmt->def =
  unL match(
    stmtTypeSig ->
      dip(swap) defTypeSig
  )

defCheck : CoreModule CoreSym Maybe(CoreDef) CoreDef -- Result(CoreError, CoreDef)
defCheck = dip(drop3) ok

def->sexp : CoreDef -- Sexp
def->sexp =
  match(
    defTypeSig ->
      dip2(nil)
      dip2("type-sig" sexpAtom cons)
      dip(locSet->str sexpAtom cons)
      ctx->sexp cons
      sexpList
  )

data CoreModule
  mkCore : Mod Map(CoreSym, CoreDef) -- CoreModule
end

unCore : CoreModule -- Mod Map(CoreSym, CoreDef)
unCore = match( mkCore -> id )

coreGet? : CoreModule CoreSym -- CoreModule CoreSym Maybe(CoreDef)
coreGet? = dip(unCore) mapGet? dip2(mkCore)

coreSet : CoreModule CoreSym CoreDef -- CoreModule
coreSet = dip2(unCore) mapSet mkCore

coreNil = mapNil mkCore
coreCons = $(
  stmt->def
  dip(coreGet?) dip2(dup2)
  defCheck result(
    dip(drop2) err,
    coreSet ok
  )
)

core->str = core->sexp sexp->str
core->sexp = $(
  unCore
  dip2(nil "core-module" sexpAtom cons)
  dip(mod->str sexpAtom cons)
  map->sexp(sym->str sexpAtom, def->sexp) cons
  sexpList
)

data CoreSym
  mkSym : Str -- CoreSym
end

unSym : CoreSym -- Str
unSym = match( mkSym -> id )

sym->str = unSym

