
import base/unit
import base/maybe
import base/void
import base/map
import base/result
import base/int
import base/str
import base/sexp
import base/list

import mirth/mod
import mirth/name
import mirth/loc
import mirth/syntax

export mirth/core
  type CEnv
  type CCtx(x)
  type CSort
  type CPrim
  type CZero
  type CSucc(x)
  type CBind
  type CTerm(x)
  type CPrim
  type CError
  type CMonad(x,t)
end

undefined : *a -- *b
undefined = "undefined" _prim_unsafe_panic

||| Syntactic sort. This represents the sort of a term,
||| i.e. what kind of syntax it represents.
data CSort

  ||| Atomic types, e.g. Int, Str.
  CSType  : CSort

  ||| Atomic values, e.g. 10, "foo"
  CSValue : CSort

  ||| Atomic word, e.g. dup, drop, dip(10 20)
  CSWord : CSort

  ||| Syntactic lists. See also: `CSList(x)`
  CSList_ : CSort -- CSort

  ||| Syntactic functions. See also: `CSArrow(a,b)`
  CSArrow__ : CSort CSort -- CSort
end

||| `CSList(x)` represents lists of sort `x`.
CSList(f: CSort) : CSort
CSList(f) = f CSList_

||| `CSArrow(a,b)` represents a lambda or primitive that takes an `a` and produces a `b`.
CSArrow(f: CSort, g: CSort) : CSort
CSArrow(f,g) = g f CSArrow__

||| Lists of atomic types, such as stack types.
CSTypes : CSort
CSTypes = CSList(CSType)

||| Lists of atomic values, such as stack values.
CSValues : CSort
CSValues = CSList(CSValue)

||| Lists of atomic words, such as word bodies.
CSWords : CSort
CSWords = CSList(CSWord)

||| Convert CSort into a string for printing. The output format
||| is meant to be easy to read, not necessarily to be useful for
||| (de)serialization. See also: `csort->sexp`
csort->str : CSort -- Str
csort->str =
  match(
    CSType -> "type",
    CSWord -> "word",
    CSValue -> "value",
    CSList_ -> csort->str "*" <>,
    CSArrow__ -> dip(csort->str "[" <>) csort->str "]" <> <>
  )

||| Convert CSort into an S-expression. The output format is
||| meant for (de)serialization. See also `csort->str`
csort->sexp : CSort -- Sexp
csort->sexp =
  match(
    CSType -> "type" sexpAtom,
    CSWord -> "word" sexpAtom,
    CSValue -> "value" sexpAtom,
    CSList_ -> dip(nil "list" sexpAtom cons) csort->sexp cons sexpList,
    CSArrow__ -> dip2(nil "->" sexpAtom cons) dip(csort->sexp cons) csort->sexp cons sexpList
  )

||| Compare two CSorts for equality.
csort= : CSort CSort -- Bool
csort= =
  match(
    CSType ->
      match(
        CSType -> true,
        _ -> drop false
      ),
    CSWord ->
      match(
        CSWord -> true,
        _ -> drop false
      ),
    CSValue ->
      match(
        CSValue -> true,
        _ -> drop false
      ),
    CSList_ ->
      swap match(
        CSList_ -> csort=,
        _ -> drop2 false
      ),
    CSArrow__ ->
      rotl match(
        CSArrow__ -> dip(swap) csort= if(csort=, drop2 false),
        _ -> drop3 false
      )
  )

||| Compare two CSorts for equality without consuming them.
csort=? : CSort CSort -- CSort CSort Bool
csort=? = dup2 csort=

||| Empty type to represent the free variables that can appear in a closed term.
data CZero
end

||| Successor type, to represent the free variables that can appear inside a lambda.
data CSucc(x)
  S_ : x -- CSucc(x)
  Z : CSucc(x)
end

|||
S(f: x) : CSucc(x)
S(f) = f S_

||| Binding information. This may contain the sort, name, multiplicity, implicity,
||| etc. of a variable that is being bound.
data CBind
  MkCBind : CSort Name -- CBind
end

unCBind : CBind -- CSort Name
unCBind = match(MkCBind -> id)

cbind->csort : CBind -- CSort
cbind->csort = unCBind drop

cbind->name : CBind -- Name
cbind->name = unCBind nip

cbind= : CBind CBind -- Bool
cbind= = both(cbind->csort) csort=

||| Separate name spaces for each core name.
data CSpace
end

||| Convert CSpace into a string for printing. This is
||| meant for easy reading, not for (de)serialization.
|||
||| See also: `cspace->sexp`
cspace->str : CSpace -- Str
cspace->str =
  match

||| Convert CSpace into an S-expression for (de)serialization.
|||
||| See also: `cspace->str`
cspace->sexp : CSpace -- Sexp
cspace->sexp =
  match

||| A Core Name is a Name bundled with its
||| syntactic sort and its space. This makes
||| each name _unique_.
data CName
  MkCName : CSort CSpace Name -- CName
end

||| Deconstructo CName
unCName : CName -- CSort CSpace Name
unCName = match(MkCName -> id)

||| Get the CSort of a CName.
cname->csort : CName -- CSort
cname->csort = unCName drop2

||| Get the CSpace of a CName.
cname->cspace : CName -- CSpace
cname->cspace = unCName drop nip

||| Get the underlying Name of a CName.
cname->name : CName -- Name
cname->name = unCName dip(drop2)

||| Convert a CName into a Str. This is meant for easy reading,
||| not for (de)serialization.
|||
||| See also: `cname->sexp`
cname->str : CName -- Str
cname->str = unCName dip2(csort->str "::" <>) dip(cspace->str "::" <> <>) name->str <>

||| Primitive operations, i.e. built-in terms or globals that do
||| not contain any variables.
data CPrim
  # Word Primitives
  CPDip : CPrim
  CPSwap : CPrim
  CPDrop : CPrim
  CPDup : CPrim
end

||| Get the CSort of a CPrim.
cprim->csort : CPrim -- CSort
cprim->csort =
  match(
    CPDip -> CSArrow(CSWords, CSWord),
    CPSwap -> CSWord,
    CPDrop -> CSWord,
    CPDup -> CSWord
  )

data CTerm(x)
  CTVar_ : x -- CTerm(x)
  CTName_ : CName -- CTerm(x)
  CTPrim_ : CPrim -- CTerm(x)
  CTNil_ : CSort -- CTerm(x)
  CTCons__ : CTerm(x) CTerm(x) -- CTerm(x)
  CTCat__ : CTerm(x) CTerm(x) -- CTerm(x)
  CTApply__ : CTerm(x) CTerm(x) -- CTerm(x)
  CTLambda__ : CBind CTerm(CSucc(x)) -- CTerm(x)
end

CTVar(f: x) : CTerm(x)
CTName(f: CName) : CTerm(x)
CTPrim(f: CPrim) : CTerm(x)
CTNil(f: CSort) : CTerm(x)
CTCons(f: CTerm(x), g: CTerm(x)) : CTerm(x)
CTCat(f: CTerm(x), g: CTerm(x)) : CTerm(x)
CTApply(f: CTerm(x), g: CTerm(x)) : CTerm(x)
CTLambda(f: CBind, g: CTerm(CSucc(x))) : CTerm(x)

CTVar(f) = f CTVar_
CTName(f) = f CTName_
CTPrim(f) = f CTPrim_
CTNil(f) = f CTNil_
CTCons(f,g) = f g CTCons__
CTCat(f,g) = f g CTCat__
CTApply(f,g) = f g CTApply__
CTLambda(f,g) = f g CTLambda__

data CCtx(x)

  ||| Raw constructor for empty context. The odd form is due to the
  ||| lack of GADTs in the bootstrap. See also: `CCZero`
  CCZero@(f: x -- CZero, g: CZero -- x) : CCtx(x)

  ||| Raw constructor for successor context. The odd form is due to the
  ||| lack of GADTs in the bootstrap. See also: `CCSucc___`
  CCSucc___@(f: x -- CSucc(y), g: CSucc(y) -- x) : CCtx(y) CBind CTerm(y) -- CCtx(x)
end

||| Constructor for empty context.
CCZero : CCtx(CZero)
CCZero = CCZero@(id, id)

||| Constructor for successor context. Note that this
||| does not check that the name in CBind is unique.
CCSucc___ : CCtx(x) CBind CTerm(x) -- CCtx(CSucc(x))
CCSucc___ = CCSucc___@(id, id)

||| Lookup the binding information for a variable.
lookupVarBind : CCtx(x) x -- CBind
lookupVarBind =
  swap match(
    CCZero@(f,g) -> f match,
    CCSucc___@(f,g) ->
      rot4l f match(
        Z -> drop nip,
        S_ -> dip(drop2) lookupVarBind
      )
  )

||| Lookup the syntactic sort for a variable.
lookupVarSort : CCtx(x) x -- CSort
lookupVarSort = lookupVarBind cbind->csort

||| Lookup the name for a variable.
lookupVarName : CCtx(x) x -- Name
lookupVarName = lookupVarBind cbind->name

||| Lookup a variable by name.
lookupVarByName : CCtx(x) Name -- Maybe(x)
lookupVarByName =
  swap match(
    CCZero@(f,g) -> drop none,
    CCSucc___@(f,g) ->
      drop cbind->name dip(swap dup) nameeq
      if(
        drop2 Z g some,
        lookupVarByName mmap(S_ g)
      )
  )

data CError
  CESortMismatch : CCtx(x) CTerm(x) CSort CSort -- CError
  CEGeneral : Str -- CError
end

cerror->str : CError -- Str
cerror->str =
  match(
    CESortMismatch ->
      dip2(drop2)
      dip2("Sort Mismatch: Expected ")
      dip(csort->str <> " but got " <>)
      csort->str <>,
    CEGeneral ->
      id
  )

cerror->sexp : CError -- Sexp
cerror->sexp =
  match(
    CESortMismatch ->
      undefined,
    CEGeneral ->
      undefined
  )

data CMonad(x, t)
  MkCMonad(
    f: CEnv CCtx(x) m -- CEnv CCtx(x) Result(CError, t)
  ) : m -- CMonad(x, t)
end

crun : CEnv CCtx(x) CMonad(x,t) -- CEnv CCtx(x) Result(CError, t)
crun = match(MkCMonad(f) -> f)

cpure : a -- CMonad(x, a)
cpure = MkCMonad(ok)

cpure2 : a b -- CMonad(x, a) CMonad(x, b)
cpure2 = dip(cpure) cpure

cmap(f: a -- b) : CMonad(x, a) -- CMonad(x, b)
cmap(f) = MkCMonad(crun rmap(f))

cmap2(f: a b -- c) : CMonad(x, a) CMonad(x, b) -- CMonad(x, c)
cmap2(f) =
  pack2 MkCMonad(
    unpack2 dip(crun) swap
    result(nip err,
      dip(crun) swap
      result(nip err, f ok)
    )
  )

cmap3(f: a b c -- d) : CMonad(x, a) CMonad(x, b) CMonad(x, c) -- CMonad(x, d)
cmap3(f) = cmap2(pack2) cmap2(unpack2 f)

cmap4(f: a b c d -- e) : CMonad(x, a) CMonad(x, b) CMonad(x, c) CMonad(x, d) -- CMonad(x, e)
cmap4(f) = cmap2(pack2) cmap3(unpack2 f)

cbind(f: a -- CMonad(x, b)) : CMonad(x, a) -- CMonad(x, b)
cbind(f) =
  MkCMonad(
    crun result(
      err,
      f crun
    )
  )

cbind2(f: a b -- CMonad(x, c)) : CMonad(x, a) CMonad(x, b) -- CMonad(x, c)
cbind2(f) = cmap2(pack2) cbind(unpack2 f)

cbind3(f: a b c -- CMonad(x, d)) : CMonad(x, a) CMonad(x, b) CMonad(x, c) -- CMonad(x, d)
cbind3(f) = cmap3(pack3) cbind(unpack3 f)

cbind4(f: a b c d -- CMonad(x, e)) : CMonad(x, a) CMonad(x, b) CMonad(x, c) CMonad(x, d) -- CMonad(x, e)
cbind4(f) = cmap4(pack4) cbind(unpack4 f)

cfail : CError -- CMonad(x,t)
cfail = MkCMonad(err)

cctx : CMonad(x, CCtx(x))
cctx = unit MkCMonad(drop dup ok)

cenv : CMonad(x, CEnv)
cenv = unit MkCMonad(drop over ok)

clookupVarSort : x -- CMonad(x, CSort)
clookupVarSort = dip(cctx) cpure cmap2(lookupVarSort)

~CSList_ : CSort -- CMonad(x, CSort)
~CSList_ =
  match(
    CSList_ -> cpure,
    _ -> dip("Expected list sort, got ") csort->str <> CEGeneral cfail
  )

~CSArrow__ : CSort -- CMonad(x, Pack(CSort CSort))
~CSArrow__ =
  match(
    CSArrow__ -> pack2 cpure,
    _ -> dip("Expected arrow sort, got ") csort->str <> CEGeneral cfail
  )

inferSort : CTerm(x) -- CMonad(x, CSort)
checkSort : CTerm(x) CSort -- CMonad(x, Unit)

inferSort =
  match(
    CTVar_ -> clookupVarSort,
    CTName_ -> cname->csort cpure,
    CTPrim_ -> cprim->csort cpure,
    CTNil_ -> CSList_ cpure,
    CTCons__ -> dip(cpure) inferSort cbind2(CSList_ dup dip(checkSort) cpure cmap2(nip)),
    CTCat__ -> dip(cpure) inferSort cbind(~CSList_) cbind2(CSList_ dup dip(checkSort) cpure cmap2(nip)),
    CTApply__ -> dip(inferSort cbind(~CSArrow__)) cpure cbind2(swap unpack2 dip(checkSort) cpure cmap2(nip)),
    CTLambda__ -> undefined
  )

checkSort =
  dip(dup) dip3(cctx) dip2(cpure) dip(inferSort) cpure cbind4(
    csort=? if(
      drop4 unit cpure,
      CESortMismatch cfail
    )
  )

