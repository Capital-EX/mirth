
import base/unit
import base/nat
import base/str
import base/map
import base/set
import base/list
import base/unsafe
import base/maybe
import base/io
import mirth/syntax
import mirth/loc

type +Mirth
type K
type W

data Meta
  MkMeta : Nat Maybe(Name) -- Meta
end

unMeta : Meta -- Nat Maybe(Name)
unMeta = match( MkMeta -> id )

meta->str : Meta -- Str
meta->str = dip("[:") unMeta dip(nat->str <>) maybe(id, dip(":" <>) name->str <>) ":]" <>

metaeq : Meta Meta -- Bool
metaeq = both(meta->str) streq

||| Core Types. The K stands for Kind or "Konstructor". In the future
||| this might included constructed values, not just types.
data K
  KVar  : Name -- K
  KMeta : Meta -- K
  KUnit : K
  KBool : K
  KInt  : K
  KStr  : K
  KPair : K K -- K
  KList : K   -- K
end

k->str  : K -- Str
k->str* : K -- Str

k->str =
  match(
    KVar -> name->str,
    KMeta -> meta->str,
    KUnit -> "[]",
    KBool -> "Bool",
    KInt -> "Int",
    KStr -> "Str",
    KList -> k->str dip("List(") <> ")" <>,
    KPair -> dip(k->str*) k->str <> dip("[") <> "]" <>
  )

k->str* =
  match(
    KUnit -> "",
    KPair -> dip(k->str*) k->str " " <> <>,
    _ -> dip("*") k->str <> " " <>
  )

||| Core Words. The W stands for Word. These operations
||| are just all the primitives we need to replicate the
||| functionality in the bootstrap. Perhaps it can be
||| somewhat trimmed.
data W
  WVar (t: K -- K +Mirth) : Name -- W
  WId   : W
  WCp   : List(W) -- W

  WDup  : W
  WDrop : W
  WSwap : W
  WDip  : W -- W

  WPack2 : W
  WUnpack2 : W
  WIntuple : W -- W

  WBoolTrue : W
  WBoolFalse : W
  WBoolIf : W W -- W

  WIntLit : Int -- W
  WIntAdd : W
  WIntSub : W
  WIntMul : W
  WIntMod : W
  WIntDiv : W
  WIntEq  : W
  WIntLt  : W

  WStrLit : Str -- W
  WStrCat : W
  WStrBreak : W
  WStrLen : W
  WStrFromCodepoint : W
  WStrToCodepoint : W
  WStrElem : W
  WStrREMatch : W

  WListNil : K -- W
  WListCons : W
  WListCat : W
  WListLen : W
  WListAt : W
  WListBreak : W
  WListMap : W -- W
  WListFor : W -- W

  WUnsafePanic : K -- W
  WUnsafeTrace : W
  WUnsafePrint : W
  WUnsafeListDir : W
  WUnsafeWalk : W
  WUnsafeIsDir : W
  WUnsafeIsFile : W
  WUnsafeRead : W
  WUnsafeWrite : W
  WUnsafeAppend : W
  WUnsafeCoerce : K -- W
  WUnsafeHash : W
  WUnsafeEnvGet : K -- W
  WUnsafeEnvSet : W
  WUnsafeEnvSave : W -- W
  WUnsafeExit : K -- W
end

MIRTH_FRESH : Str
MIRTH_KMETA : Str
MIRTH_FRESH = "Mirth.fresh"
MIRTH_KMETA = "Mirth.kmeta"

initElabEnv : +Mirth
initMirth : +Mirth
initMirth = $(
  n0 unsafe_env_set(MIRTH_FRESH)
  mapNil unsafe_env_set(MIRTH_KMETA)
  initElabEnv
)

runMirth(f: *a -- *b +Mirth) : *a -- *b +IO
runMirth(f) = $(
  unsafe_env_save(MIRTH_FRESH,
  unsafe_env_save(MIRTH_KMETA,
    initMirth f
  ))
  unsafe_coerce
)

typeError : *a Str -- *b +Mirth
typeError = "Type Error: " swap <> unsafe_panic

freshNat : Nat +Mirth
freshNat = $(
  unsafe_env_get(MIRTH_FRESH)
  n1+ pnat dup
  unsafe_env_set(MIRTH_FRESH)
)

kfresh : K +Mirth
kfresh = freshNat none MkMeta KMeta

kmetaget : Meta -- Maybe(K) +Mirth
kmetaget = unsafe_env_get(MIRTH_KMETA) swap mapGet

kmetaset : Meta K -- +Mirth
kmetaset = unsafe_env_get(MIRTH_KMETA) rotr mapSet unsafe_env_set(MIRTH_KMETA)

kexpand : K -- K +Mirth
kexpand =
  match(
    KMeta -> dup kmetaget maybe(KMeta, nip kexpand),
    _ -> id
  )

khasmeta? : Meta K -- Meta K Bool +Mirth
khasmeta  : Meta K --        Bool +Mirth
khasmeta =
  match(
    KMeta -> metaeq,
    KList -> khasmeta,
    KPair -> or?(dip?(khasmeta?), swap?(dip?(khasmeta?))) dip(drop3),
    _ -> drop2 false
  )
khasmeta? = dup2 khasmeta

kmetamatch2 : Meta Meta -- K +Mirth
kmetamatch1 : Meta K -- K +Mirth
kmetamatch(fallback: K K -- K +Mirth) : K K -- K +Mirth
kmetamatch(fallback) =
  match(
    KMeta ->
      swap match(
        KMeta -> kmetamatch2,
        _ -> kmetamatch1
      ),
    _ ->
      swap match(
        KMeta -> swap kmetamatch1,
        _ -> fallback
      )
  )

kmetamatch2 =
  dup2 metaeq if(
    drop KMeta,
    KMeta dup dip(kmetaset)
  )

kmetamatch1 =
  dup2 khasmeta if(
    dip2("Can't unify ")
    dip(meta->str <> " with " <>)
    k->str <>
    typeError,
    dup dip(kmetaset)
  )

~KVar  : K -- Name +Mirth
~KMeta : K -- Meta +Mirth
~KUnit : K -- +Mirth
~KBool : K -- +Mirth
~KInt  : K -- +Mirth
~KStr  : K -- +Mirth
~KPair : K -- K K +Mirth
~KList : K -- K +Mirth

~KVar  = kexpand match( KVar  -> id, _ -> "Expected type var." typeError)
~KMeta = kexpand match( KMeta -> id, _ -> "Expected meta var." typeError)
~KUnit = kexpand match( KUnit -> id, _ -> "Expected []." typeError)
~KBool = kexpand match( KBool -> id, _ -> "Expected Bool." typeError)
~KInt  = kexpand match( KInt  -> id, _ -> "Expected Int." typeError)
~KStr  = kexpand match( KStr  -> id, _ -> "Expected Str." typeError)
~KPair = kexpand match( KPair -> id, _ -> "Expected stack item." typeError)
~KList = kexpand match( KList -> id, _ -> "Expected List." typeError)

kunify : K K -- K +Mirth
kunify2 : K K K K -- K K +Mirth

kunify =
  dip(kexpand) kexpand kmetamatch(match(
    KVar -> dip(~KVar) over nameeq
      if(KVar, "mismatched type vars" typeError),
    KMeta -> dip(~KMeta) over metaeq
      if(KMeta, "mismatched meta vars" typeError),
    KUnit -> ~KUnit KUnit,
    KBool -> ~KBool KBool,
    KInt  -> ~KInt  KInt,
    KStr  -> ~KStr  KStr,
    KPair -> dip2(~KPair) kunify2 KPair,
    KList -> dip(~KList) kunify KList
  ))

kunify2 = dip(swap) dip2(kunify) kunify

kpop : K -- K K +Mirth
kpop = ~KPair

kpop2 : K -- K K K +Mirth
kpop2 = kpop dip(kpop)

kpush : K K -- K
kpush = KPair

kpush2 : K K K -- K
kpush2 = dip(kpush) kpush

infer : K W -- K +Mirth
infer =
  match(
    WVar(inferVar) -> drop inferVar,
    WId -> id,
    WCp -> for(infer),

    WDup -> kpop dup kpush2,
    WDrop -> kpop drop,
    WSwap -> kpop2 swap kpush2,
    WDip -> dip(kpop) swap dip(infer) kpush,

    WPack2 -> kpop2 dip2(KUnit) kpush2 kpush,
    WUnpack2 -> kpop kpop2 dip2(~KUnit) kpush2,
    WIntuple -> dip(kpop) infer kpush,

    WBoolTrue -> KBool kpush,
    WBoolFalse -> KBool kpush,
    WBoolIf ->
      dip2(kpop ~KBool) dip(over)
      dip2(infer) infer kunify,

    WIntLit -> drop KInt kpush,
    WIntAdd -> kpop2 ~KInt ~KInt KInt kpush,
    WIntSub -> kpop2 ~KInt ~KInt KInt kpush,
    WIntMul -> kpop2 ~KInt ~KInt KInt kpush,
    WIntMod -> kpop2 ~KInt ~KInt KInt kpush,
    WIntDiv -> kpop2 ~KInt ~KInt KInt kpush,
    WIntEq -> kpop2 ~KInt ~KInt KBool kpush,
    WIntLt -> kpop2 ~KInt ~KInt KBool kpush,

    WStrLit -> drop KStr kpush,
    WStrCat -> kpop2 ~KStr ~KStr KStr kpush,
    WStrBreak -> kpop2 ~KInt ~KStr KStr KStr kpush2,
    WStrLen -> kpop ~KStr KInt kpush,
    WStrFromCodepoint -> kpop ~KInt KStr kpush,
    WStrToCodepoint -> kpop ~KStr KInt kpush,
    WStrElem -> kpop2 ~KStr ~KStr KBool kpush,
    WStrREMatch -> kpop2 ~KStr ~KStr KInt KBool kpush2,

    WListNil -> KList kpush,
    WListCons -> kpop2 dip(~KList) kunify KList kpush,
    WListCat -> kpop2 dip(~KList) ~KList kunify KList kpush,
    WListLen -> kpop ~KList drop KInt kpush,
    WListAt -> kpop2 ~KInt ~KList kpush,
    WListBreak -> kpop2 ~KInt ~KList KList dup kpush2,
    WListMap ->
      dip(kpop ~KList dip(KUnit) KPair) infer
      ~KPair dip(~KUnit) KList kpush,
    WListFor ->
      dip(kpop dip(dup) ~KList kpush) infer kunify,

    WUnsafePanic -> dip(kpop ~KStr drop),
    WUnsafeTrace -> kpop ~KStr,
    WUnsafePrint -> kpop ~KStr,
    WUnsafeListDir -> kpop ~KStr KStr KList kpush,
    WUnsafeWalk -> kpop ~KStr KUnit KStr kpush KStr KList dup kpush2 kpush,
    WUnsafeIsDir -> kpop ~KStr KBool kpush,
    WUnsafeIsFile -> kpop ~KStr KBool kpush,
    WUnsafeRead -> kpop ~KStr KStr kpush,
    WUnsafeWrite -> kpop2 ~KStr ~KStr,
    WUnsafeAppend -> kpop2 ~KStr ~KStr,
    WUnsafeCoerce -> nip,
    WUnsafeHash -> kpop drop KInt kpush,
    WUnsafeEnvGet -> dip(kpop ~KStr) kpush,
    WUnsafeEnvSet -> kpop2 ~KStr drop,
    WUnsafeEnvSave -> dip(kpop ~KStr) infer,
    WUnsafeExit -> dip(kpop ~KInt drop)
  )

##############
# ELABORATOR #
##############

MIRTH_ELAB_ENV : Str
MIRTH_ELAB_ENV = "Mirth.elab.env"

data ElabDef
  ElabDefWord(f: K Args w -- K W +Mirth) : w -- ElabDef
end

data ElabEnv
  MkElabEnv : Map(Name, ElabDef) -- ElabEnv
end

unElabEnv : ElabEnv -- Map(Name, ElabDef)
unElabEnv = match(MkElabEnv -> id)

getElabEnv : ElabEnv +Mirth
setElabEnv : ElabEnv -- +Mirth
withElabEnv(f: *a ElabEnv -- *b ElabEnv) : *a -- *b +Mirth

getElabEnv = unsafe_env_get(MIRTH_ELAB_ENV)
setElabEnv = unsafe_env_set(MIRTH_ELAB_ENV)
withElabEnv(f) = getElabEnv f setElabEnv

getElabDef : Name -- Maybe(ElabDef) +Mirth
setElabDef : Name ElabDef -- +Mirth
getElabDef = getElabEnv unElabEnv swap mapGet
setElabDef = getElabEnv unElabEnv rotr mapSet MkElabEnv setElabEnv

initialElabMap : Map(Name, ElabDef)

initElabEnv : +Mirth
initElabEnv = initialElabMap MkElabEnv unsafe_env_set(MIRTH_ELAB_ENV)

elabExpr : K Expr -- K W +Mirth
elabAtom : K Atom -- K W +Mirth
elabWord : K Word -- K W +Mirth
elabInt : K Int -- K W +Mirth
elabStr : K Str -- K W +Mirth

elabLExpr : K L(Expr) -- K W +Mirth
elabLAtom : K L(Atom) -- K W +Mirth
elabLWord : K L(Word) -- K W +Mirth
elabLInt : K L(Int) -- K W +Mirth
elabLStr : K L(Str) -- K W +Mirth

elabExpr = unExpr formap(elabLAtom) WCp
elabAtom = matchAtom(elabLWord, elabLInt, elabLStr)
elabWord = $(
  # TODO check in locals first
  dup wordName getL getElabDef
  maybe(
    wordName getL name->str " is not defined" <> typeError,
    match(ElabDefWord(f) -> dip(wordArgs getL) f)
  )
)
elabInt = dip(KInt kpush) WIntLit
elabStr = dip(KStr kpush) WStrLit

elabLExpr = getL elabExpr
elabLAtom = getL elabAtom
elabLWord = getL elabWord
elabLInt = getL elabInt
elabLStr = getL elabStr

##############
# Primitives #
##############

expect0Args : Args -- +Mirth
expect1Args : Args -- Expr +Mirth
expect2Args : Args -- Expr Expr +Mirth

wPrim : K Args W -- K W +Mirth
wPrim = dip(expect0Args) dup dip(infer)

addPrim(f: K Args -- K W +Mirth)
  : Map(Name, ElabDef) Str -- Map(Name, ElabDef)
addPrim(f) = mkName unit ElabDefWord(drop f) mapSet

primDip : K Args -- K W +Mirth
primIntuple : K Args -- K W +Mirth
primBoolIf : K Args -- K W +Mirth
primListNil : K Args -- K W +Mirth
primListMap : K Args -- K W +Mirth
primListFor : K Args -- K W +Mirth
primUnsafePanic : K Args -- K W +Mirth
primUnsafeCoerce : K Args -- K W +Mirth
primUnsafeEnvGet : K Args -- K W +Mirth
primUnsafeEnvSave : K Args -- K W +Mirth
primUnsafeExit : K Args -- K W +Mirth

initialElabMap = $(
  mapNil
  "_prim_dup" addPrim(WDup wPrim)
  "_prim_swap" addPrim(WSwap wPrim)
  "_prim_drop" addPrim(WDrop wPrim)
  "_prim_dip" addPrim(primDip)

  "_prim_tuple_intuple" addPrim(primIntuple)
  "_prim_tuple_pack2" addPrim(WPack2 wPrim)
  "_prim_tuple_unpack2" addPrim(WUnpack2 wPrim)

  "_prim_bool_true" addPrim(WBoolTrue wPrim)
  "_prim_bool_false" addPrim(WBoolFalse wPrim)
  "_prim_bool_if" addPrim(primBoolIf)

  "_prim_int_add" addPrim(WIntAdd wPrim)
  "_prim_int_sub" addPrim(WIntSub wPrim)
  "_prim_int_mul" addPrim(WIntMul wPrim)
  "_prim_int_mod" addPrim(WIntMod wPrim)
  "_prim_int_div" addPrim(WIntDiv wPrim)
  "_prim_int_eq" addPrim(WIntEq wPrim)
  "_prim_int_lt" addPrim(WIntLt wPrim)

  "_prim_str_cat" addPrim(WStrCat wPrim)
  "_prim_str_break" addPrim(WStrBreak wPrim)
  "_prim_str_len" addPrim(WStrLen wPrim)
  "_prim_str_from_codepoint" addPrim(WStrFromCodepoint wPrim)
  "_prim_str_to_codepoint" addPrim(WStrToCodepoint wPrim)
  "_prim_str_elem" addPrim(WStrElem wPrim)
  "_prim_str_rematch" addPrim(WStrREMatch wPrim)

  "_prim_list_nil" addPrim(primListNil)
  "_prim_list_cons" addPrim(WListCons wPrim)
  "_prim_list_cat" addPrim(WListCat wPrim)
  "_prim_list_len" addPrim(WListLen wPrim)
  "_prim_list_at" addPrim(WListAt wPrim)
  "_prim_list_break" addPrim(WListBreak wPrim)
  "_prim_list_map" addPrim(primListMap)
  "_prim_list_for" addPrim(primListFor)

  "_prim_unsafe_panic" addPrim(primUnsafePanic)
  "_prim_unsafe_trace" addPrim(WUnsafeTrace wPrim)
  "_prim_unsafe_print" addPrim(WUnsafePrint wPrim)
  "_prim_unsafe_listdir" addPrim(WUnsafeListDir wPrim)
  "_prim_unsafe_walk" addPrim(WUnsafeWalk wPrim)
  "_prim_unsafe_isdir" addPrim(WUnsafeIsDir wPrim)
  "_prim_unsafe_isfile" addPrim(WUnsafeIsFile wPrim)
  "_prim_unsafe_read" addPrim(WUnsafeRead wPrim)
  "_prim_unsafe_write" addPrim(WUnsafeWrite wPrim)
  "_prim_unsafe_append" addPrim(WUnsafeAppend wPrim)
  "_prim_unsafe_coerce" addPrim(primUnsafeCoerce)
  "_prim_unsafe_hash" addPrim(WUnsafeHash wPrim)
  "_prim_unsafe_env_get" addPrim(primUnsafeEnvGet)
  "_prim_unsafe_env_set" addPrim(WUnsafeEnvSet wPrim)
  "_prim_unsafe_env_save" addPrim(primUnsafeEnvSave)
  "_prim_unsafe_exit" addPrim(primUnsafeExit)
)

primDip = $(
  expect1Args dip(kpop) swap
  dip(elabExpr) swap dip(kpush)
)

primIntuple = expect1Args dip(kpop) elabExpr dip(kpush) WIntuple

primBoolIf = $(
  expect2Args dip2(kpop ~KBool) dip(over)
  dip2(elabExpr) elabExpr dip(swap)
  dip2(kunify) WBoolIf
)

primListNil = $(
  expect0Args kfresh dup dip(KList kpush) WListNil
)

primListMap = $(
  expect1Args
  dip(kpop ~KList dip(KUnit) kpush) elabExpr
  dip(kpop dip(~KUnit) KList kpush) WListMap
)

primListFor = $(
  expect1Args
  dip(kpop dip(dup) ~KList kpush) elabExpr
  dip(kunify) WListFor
)

primUnsafePanic = $(
  expect0Args kpop ~KStr drop kfresh dup WUnsafePanic
)

primUnsafeCoerce = $(
  expect0Args drop kfresh dup WUnsafeCoerce
)

primUnsafeExit = $(
  expect0Args kpop ~KInt drop kfresh dup WUnsafeExit
)

primUnsafeEnvGet = $(
  expect0Args kpop ~KStr kfresh dup dip(kpush) WUnsafeEnvGet
)

primUnsafeEnvSave = $(
  expect1Args dip(kpop ~KStr) elabExpr WUnsafeEnvSave
)


