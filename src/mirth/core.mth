
import base/unit
import base/maybe
import base/void
import base/map
import base/result
import base/int
import base/str
import base/sexp
import base/list

import mirth/mod
import mirth/name
import mirth/loc
import mirth/syntax

export mirth/core
  type Name

  type CZero
  type CSucc(x)

  type CEnv
  type CDef
  type CCtx(x)
  type CSpace
  type CSymbol
  type CImplicit
  type CBind
  type CKind(x)

  type CSort
  type CKind(x)
  type CTerm(x)
  type CStackType(x)
  type CValueType(x)
  type CStack(x)
  type CValue(x)
  type CWord(x)

  type CError
  type CMonad(x,t)

  ctmSubst (f: *g a -- *g CTerm(a)) : *g CTerm(a) -- *g CTerm(b)
  cstSubst (f: *g a -- *g CTerm(a)) : *g CStackType(a) -- *g CStackType(b)
  cvtSubst (f: *g a -- *g CTerm(a)) : *g CValueType(a) -- *g CValueType(b)
  csSubst (f: *g a -- *g CTerm(a)) : *g CStack(a) -- *g CStack(b)
  cvSubst (f: *g a -- *g CTerm(a)) : *g CValue(a) -- *g CValue(b)
  cwSubst (f: *g a -- *g CTerm(a)) : *g CWord(a) -- *g CWord(b)
end

||| Empty type to represent the free variables that can appear in a closed term.
data CZero
end

||| Successor type, to represent the free variables that can appear inside a lambda.
data CSucc(x)
  Z : CSucc(x)
  S : x -- CSucc(x)
end

csucc(f: *a -- *b, g: *a x -- *b) : *a CSucc(x) -- *b
csucc(f, g) =
  match(
    Z -> f,
    S -> g
  )

data CImplicit
  MkCImplicit : Bool -- CImplicit
end

||| Binding information. This may contain the sort, name, multiplicity, implicity,
||| etc. of a variable that is being bound.
data CBind
  MkCBind : CImplicit Name -- CBind
end

||| Separate name spaces for each core name.
data CSpace
  CSpPrim : CSpace
  CSpMod : Mod -- CSpace
  CSpPkg : Pkg -- CSpace
  CSpIface : Interface -- CSpace
end

||| A Core Symbol is a Name bundled with its
||| name space. This makes each name _unique_.
data CSymbol
  MkCSymbol : CSpace Name -- CSymbol
end

data CSort
  CSStackType : CSort
  CSValueType : CSort
  CSStack : CSort
  CSValue : CSort
  CSWord : CSort
end

data CKind(x)
  CKStackType : CKind(x)
  CKValueType : CKind(x)
  CKStack : CStackType(x) -- CKind(x)
  CKValue : CValueType(x) -- CKind(x)
  CKWord : CStackType(x) CStackType(x) -- CKind(x)
end

data CTerm(x)
  CTStackType : CStackType(x) -- CTerm(x)
  CTValueType : CValueType(x) -- CTerm(x)
  CTStack : CStack(x) -- CTerm(x)
  CTValue : CValue(x) -- CTerm(x)
  CTWord : CWord(x) -- CTerm(x)
end

data CStackType(x)
  CSTVar  : x -- CStack(x)
  CSTNil  : CStack(x)
  CSTCons : CStack(x) CType(x) -- CStack(x)
  CSTCat  : CStack(x) CStack(x) -- CStack(x)
end

data CValueType(x)
  CVTVar : x -- CType(x)
  CVTSym : CSymbol List(CTerm(x)) -- CType(x)
end

data CStack(x)
  CSVar : x -- CStack(x)
  CSCons : CStack(x) CValue(x) -- CStack(x)
  CSTail : CStack(x) -- CStack(x)
  CSRun : CStack(x) CWord(x) -- CStack(x)
end

data CValue(x)
  CVVar : x -- CValue(x)
  CVSym : CSymbol List(CTerm(x)) -- CValue(x)
  CVHead : CStack(x) -- CValue(x)
end

data CWord(x)
  CWVar : x -- CType(x)
  CWSym : CSymbol List(CTerm(x)) -- CWord(x)
  CWPush : CData(x) -- CWord(x)
end

data CCtx(x)
  CCZ' (f: CZero -- x, g: x -- CZero) : CCtx(x)
  CCS' (f: CSucc(y) -- x, g: x -- CSucc(y)) : CCtx(y) CBind CKind(y) -- CCtx(x)
end

data CDef
  MkCDef : CCtx(x) CKind(x) Maybe(CTerm(x))
end

data CEnv
  MkCEnv : Map(CSymbol, CDef) -- CEnv
end

undefined : *a -- *b
undefined = "undefined" _prim_unsafe_panic

unexpected(m: Str) : *a -- *b
unexpected(m) = "unexpected: " m <> _prim_unsafe_panic

ctmSubst (f: *g a -- *g CTerm(a)) : *g CTerm(a) -- *g CTerm(b)
cstSubst (f: *g a -- *g CTerm(a)) : *g CStackType(a) -- *g CStackType(b)
cvtSubst (f: *g a -- *g CTerm(a)) : *g CValueType(a) -- *g CValueType(b)
csSubst (f: *g a -- *g CTerm(a)) : *g CStack(a) -- *g CStack(b)
cvSubst (f: *g a -- *g CTerm(a)) : *g CValue(a) -- *g CValue(b)
cwSubst (f: *g a -- *g CTerm(a)) : *g CWord(a) -- *g CWord(b)

