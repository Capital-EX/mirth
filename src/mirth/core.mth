# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import base/maybe
import base/result
import base/int
import base/nat
import base/str
import base/list
import base/void
import mirth/loc
import mirth/name

||| Placeholder.
undefined : *a -- *b
undefined = "undefined" _prim_unsafe_panic

||| Control whether an argument is usually passed implicitly or explicitly.
data Visibility
  Implicit : Visibility
  Explicit : Visibility
end

||| Syntactic Kind
data Kind
  KStackType : Kind
  KStack : Kind
  KValueType : Kind
  KValue : Kind
  KWord : Kind
  KLambda : Kind Kind -- Kind
end

KWordType : Kind
KWordType = KStackType KStackType KLambda

kind->str : Kind -- Str
kind->str =
  match(
    KStackType -> "stack type",
    KStack -> "stack",
    KValueType -> "value type",
    KValue -> "value",
    KWord -> "word",
    KLambda -> dip2("(") dip(kind->str <> ") -> " <>) kind->str <>
  )

kindeq : Kind Kind -- Bool
kindeq =
  match(
    KStackType ->
      match(
        KStackType -> true,
        _ -> drop false
      ),
    KStack ->
      match(
        KStack -> true,
        _ -> drop false
      ),
    KValueType ->
      match(
        KValueType -> true,
        _ -> drop false
      ),
    KValue ->
      match(
        KValue -> true,
        _ -> drop false
      ),
    KWord ->
      match(
        KWord -> true,
        _ -> drop false
      ),
    KLambda ->
      rotl match(
        KLambda -> dip(swap) dip2(kindeq) kindeq and,
        _ -> drop3 false
      )
  )

kindeq? : Kind Kind -- Kind Kind Bool
kindeq? = dup2 kindeq

||| Type of globals. These are unique descriptions of a word / type / etc.
||| These are unique accross all modules and packages. Note that a particular
||| word / type may not have the same global in differently versioned packages.
data Global
  MkGlobal : Kind Name -- Global
end

unGlobal : Global -- Kind Name
unGlobal = match(MkGlobal -> id)

globalKind : Global -- Kind
globalKind = unGlobal drop

globalName : Global -- Name
globalName = unGlobal nip

global->str : Global -- Str
global->str = globalName name->str

||| Primitives i.e. Mirth built-ins
data Prim
  # Polymorphic Primitives
  PError : L(Str) Kind -- Prim

  # StackType Primitives
  PSTNil : Prim
  PSTCons : Prim
  PSTRun : Prim
  PSTExpect : Kind -- Prim
  PSTExpectCons : Kind -- Prim

  # Stack Primitives
  PSNil : Prim
  PSCons : Prim
  PSRun : Prim

  # ValueType Primitives
  PVTInt : Prim
  PVTStr : Prim
  PVTExpect : Kind -- Prim

  # Value Primitives
  PVInt : Int -- Prim
  PVStr : Str -- Prim

  # Word Primitives
  PWId : Prim
  PWCp : Prim
  PWDup : Prim
  PWDrop : Prim
  PWSwap : Prim
  PWDip : Prim
  PWWeak : Prim
  PWPush : Prim
end

||| Show primitive as string.
prim->str : Prim -- Str
prim->str =
  match(
    PError -> drop dip("PError[") unL dip(locSet->str) <> showStr <> "]" <>,
    PSTNil -> "PSTNil",
    PSTCons -> "PSTCons",
    PSTRun -> "PSTRun",
    PSTExpect -> drop "PSTExpect",
    PSTExpectCons -> drop "PSTExpectCons",
    PSNil -> "PSNil",
    PSCons -> "PSCons",
    PSRun -> "PSRun",
    PVTInt -> "PVTInt",
    PVTStr -> "PVTStr",
    PVTExpect -> drop "PVTExpect",
    PVInt -> dip("PVInt[") int->str <> "]" <>,
    PVStr -> dip("PVStr[") showStr <> "]" <>,
    PWId -> "PWId",
    PWCp -> "PWCp",
    PWDup -> "PWDup",
    PWDrop -> "PWDrop",
    PWSwap -> "PWSwap",
    PWDip -> "PWDip",
    PWWeak -> "PWWeak",
    PWPush -> "PWPush"
  )

||| Syntactic kind for each primitive.
primKind : Prim -- Kind
primKind =
  match(
    PError -> nip,

    # Stack Type Primitives
    PSTNil -> KStackType,
    PSTCons -> KStackType KValueType KStackType KLambda KLambda,
    PSTRun -> KStackType KWord KStackType KLambda KLambda,
    PSTExpect -> dip(KStackType KStackType) dup KLambda KLambda KLambda,
    PSTExpectCons ->
      dup dip(dip(KValueType KStackType) KLambda KLambda KStackType) KLambda KLambda,

    # Stack Primitives
    PSNil -> KStack,
    PSCons -> KStack KValue KStack KLambda KLambda,
    PSRun -> KStack KWord KStack KLambda KLambda,

    # Value Type Primitives
    PVTInt -> KValueType,
    PVTStr -> KValueType,
    PVTExpect -> dip(KValueType KValueType) dup KLambda KLambda KLambda,

    # Value Primitives
    PVInt -> drop KValue,
    PVStr -> drop KValue,

    # Word Primitives
    PWId   -> KWord,
    PWCp   -> KWord KWord KWord KLambda KLambda,
    PWDup  -> KWord,
    PWDrop -> KWord,
    PWSwap -> KWord,
    PWDip  -> KWord KWord KLambda,
    PWWeak -> KWord KWord KLambda,
    PWPush -> KValue KValueType KWord KLambda KLambda
  )

||| Terms.
data Term(x)
  TLocal : L(x) -- Term(x)
  TGlobal : L(Global) -- Term(x)
  TPrim : L(Prim) -- Term(x)
  TLambda : Kind L(Term(Maybe(x))) -- Term(x)
  TApply : L(Term(x)) L(Term(x)) -- Term(x)
end

term->str_aux(f: *ctx x -- *ctx Str) : *ctx Int Term(x) -- *ctx Int Str
term->str_aux(f) =
  match(
    TLocal -> getL dip'(f) dip("L:") <>,
    TGlobal -> getL dip("G:") global->str <>,
    TPrim -> getL dip("P:") prim->str <>,
    TApply -> dip(getL term->str_aux(f) dip("A: ") <> " (" <>) dip'(getL term->str_aux(f)) <> ")" <>,
    TLambda ->
      nip dip(dup z1+ dip(int->str))
      getL term->str_aux(maybe(dup, dip'(f)))
      dip(nip)
  )

||| Turn a term into a string.
term->str(f: *ctx x -- *ctx Str) : *ctx Term(x) -- *ctx Str
term->str(f) = dip(0) term->str_aux(f) nip

||| Change the value (and possibly the type) of all the free variables in a term.
rename  (f: *ctx a -- *ctx b) : *ctx   Term(a)  -- *ctx   Term(b)
renameL (f: *ctx a -- *ctx b) : *ctx L(Term(a)) -- *ctx L(Term(b))

rename(f) =
  match(
    TLocal -> unL dip'(f) mkL TLocal,
    TGlobal -> TGlobal,
    TPrim -> TPrim,
    TLambda -> renameL(maybe(none, dip'(f) some)) TLambda,
    TApply -> dip(renameL(f)) dip'(renameL(f)) TApply
  )

renameL(f) = unL dip'(rename(f)) mkL

||| Shift all free variables in a term to make room for a new variable.
rename1 : Term(a) -- Term(Maybe(a))
rename1 = rename(some)

||| Substitute every free variable with a term given by the function.
subst  (f: *ctx L(a) -- *ctx Term(b)) : *ctx   Term(a)  -- *ctx   Term(b)
substL (f: *ctx L(a) -- *ctx Term(b)) : *ctx L(Term(a)) -- *ctx L(Term(b))

subst(f) =
  match(
    TLocal -> f,
    TGlobal -> TGlobal,
    TPrim -> TPrim,
    TLambda -> dip'(substL(unL maybe(none mkL TLocal, mkL f rename1))) TLambda,
    TApply -> dip(substL(f)) dip'(substL(f)) TApply
  )

substL(f) = unL dip'(subst(f)) mkL

||| Substitute a single variable, as in beta reduction.
subst1 : Term(Maybe(a)) Term(a) -- Term(a)
subst1 = swap subst(unL maybe(drop dup, mkL TLocal)) nip

data KindError
  MkKindError : L(Str) -- KindError
end

||| Determine the syntactic kind of a term. This is guaranteed
||| to terminate, returning an error if the term is not well-typed.
inferKind  (f: *ctx L(x) -- *ctx Result(KindError, Kind)) : *ctx   Term(x)  -- *ctx Result(KindError, Kind)
inferKindL (f: *ctx L(x) -- *ctx Result(KindError, Kind)) : *ctx L(Term(x)) -- *ctx Result(KindError, Kind)

inferKind(f) =
  match(
    TLocal -> f,
    TGlobal -> getL globalKind ok,
    TPrim -> getL primKind ok,
    TLambda ->
      inferKindL(
        unL maybe(
          drop dup ok,
          mkL dip'(f)
        )
      )
      result(
        nip err,
        KLambda ok
      ),
    TApply ->
      dip(unL dip'(inferKind(f))) swap
      result(
        dip(drop2) err,
        match(
          KLambda ->
            dip2(nip unL dip'(inferKind(f))) rotl
            result(
              dip(drop3) err,
              _prim_unsafe_coerce
              rotr dip?(kindeq?) if(
                dip(drop3) ok,
                drop swap
                dip2("Core Kind Error: Expected ")
                dip(kind->str <> " but got " <>)
                kind->str <> mkL
                MkKindError err
              )
            ),

          _ ->
            nip
            dip("Core Kind Error: Expected a lambda kind but got ") kind->str <>
            " (function is applied to too many arguments?)" <> mkL
            MkKindError
            err
        )
      )
  )

inferKindL(f) = getL inferKind(f)

||| Same as inferKind but for closed terms.
inferKind0 : Term(Void) -- Result(KindError, Kind)
inferKind0 = inferKind(getL absurd)

PVTInt pureL TPrim inferKind0 == KValueType ok
PWSwap pureL TPrim inferKind0 == KWord ok
KWord none pureL TLocal pureL TLambda inferKind0 == KWord KWord KLambda ok

||| HTerm(x) is a Term(x) in weak head normal form. This means it is
||| either a lambda term, or one of the atomic terms applied to some
||| number of arguments (not in normal form).
data HTerm(x)
  HTLocal : L(x) List(L(Term(x))) -- HTerm(x)
  HTGlobal : L(Global) List(L(Term(x))) -- HTerm(x)
  HTPrim : L(Prim) List(L(Term(x))) -- HTerm(x)
  HTLambda : Kind L(Term(Maybe(x))) -- HTerm(x)
end

||| Turn a term into an HTerm by beta reduction, with the additional
||| arguments provided. This is only guaranteed to terminate if the
||| terms involved are well-kinded, as is the application.
htermApply : Term(x) List(L(Term(x))) -- HTerm(x)
htermApply =
  swap match(
    TLocal -> swap HTLocal,
    TGlobal -> swap HTGlobal,
    TPrim -> swap HTPrim,
    TApply -> dip(getL swap) swap consL htermApply,
    TLambda ->
      rotl lmatchL(
        HTLambda,
        dip3(drop) dip2(getL) dip(getL subst1) htermApply
      )
  )

||| Turn a term into an HTerm by beta-reduction. This is only
||| guaranteed to terminate if the term is well kinded.
hterm : Term(x) -- HTerm(x)
hterm = nil htermApply

||| Turn an HTerm into a Term. This always succeeds. Note that
||| some location info is lost when translating from a Term to
||| an HTerm and back.
term : HTerm(x) -- Term(x)
term =
  match(
    HTLocal -> dip(TLocal) for(dip(pureL) TApply),
    HTGlobal -> dip(TGlobal) for(dip(pureL) TApply),
    HTPrim -> dip(TPrim) for(dip(pureL) TApply),
    HTLambda -> TLambda
  )

||| Get the type of a word. This takes a KWord and returns a KWordType.
||| Lambdas and applications are preserved. Otherwise we get an error.
||| Only guaranteed to terminate for well-kinded terms.
wordType : Term(x) -- Term(x)

||| Get the type of a word primitive. Like wordType, lambdas are preserved.
||| Guaranteed to terminate. Note that type-level eliminators like PSTExpect*
||| and PVTExpect* are not allowed, even though they might have the right type.
primWordType : L(Prim) -- Term(x)
primWordType =
  unL match(
    PError ->
      PError mkL TPrim,

    PWId -> # \x. x
      drop
      KStackType
      none pureL TLocal pureL
      TLambda,

    PWDrop -> # PSTExpectCons (\xy. y)
      drop
      KStackType PSTExpectCons pureL TPrim pureL
      KValueType KStackType
      none pureL TLocal pureL
      TLambda pureL TLambda pureL
      TApply,

    PWDup -> # PSTExpectCons (\xy. PSTCons(PSTCons(y, x), x))
      drop
      KStackType PSTExpectCons pureL TPrim pureL
      KValueType KStackType
      PSTCons pureL TPrim pureL
      PSTCons pureL TPrim pureL
      none pureL TLocal pureL TApply pureL
      none some pureL TLocal pureL TApply pureL TApply pureL
      none some pureL TLocal pureL TApply pureL
      TLambda pureL TLambda pureL
      TApply,

    _ ->
      dip("Expected a word primitive, but got ") prim->str <>
      dip(dup) mkL KWordType PError mkL TPrim
  )

