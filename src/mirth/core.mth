
import base/unit
import base/maybe
import base/void
import base/map
import base/result
import base/int
import base/str
import base/sexp
import base/list

import mirth/mod
import mirth/name
import mirth/loc
import mirth/syntax

export mirth/core
  type CZero
  type CSucc(x)

  type CEnv
  type CDef
  type CSort
  type CCtx(x)
  type CVar(x)
  type CKind(x)
  type CType(x)
  type CWord(x)

  type CError
  type CMonad(x,t)
end

undefined : *a -- *b
undefined = "undefined" _prim_unsafe_panic

||| Syntactic sort. This represents the sort of a term,
||| i.e. what kind of syntax it represents.
data CSort
  CSType : CSort
  CSWord : CSort
end

||| Kind of a binding. This implies both the sort and,
||| where applicable, the type.
data CKind(x)
  CKType : CKind(x)
  CKWord : CType(x) CType(x) -- CKind(x)
end

||| Convert CSort into a string for printing. The output format
||| is meant to be easy to read, not necessarily to be useful for
||| (de)serialization. See also: `csort->sexp`
csort->str : CSort -- Str
csort->str =
  match(
    CSType -> "type",
    CSWord -> "word"
  )

||| Convert CSort into an S-expression. The output format is
||| meant for (de)serialization. See also `csort->str`
csort->sexp : CSort -- Sexp
csort->sexp =
  match(
    CSType -> "type" sexpAtom,
    CSWord -> "word" sexpAtom
  )

||| Compare two CSorts for equality.
csort= : CSort CSort -- Bool
csort= =
  match(
    CSType -> 
      match(
        CSType -> true,
        _ -> drop false
      ),
    CSWord ->
      match(
        CSWord -> true,
        _ -> drop false
      )
  )

||| Compare two CSorts for equality without consuming them.
csort=? : CSort CSort -- CSort CSort Bool
csort=? = dup2 csort=

||| Empty type to represent the free variables that can appear in a closed term.
data CZero
end

||| Successor type, to represent the free variables that can appear inside a lambda.
data CSucc(x)
  Z : CSucc(x)
  S : x -- CSucc(x)
end

csucc(f: *a -- *b, g: *a x -- *b) : *a CSucc(x) -- *b
csucc(f, g) =
  match(
    Z -> f,
    S -> g
  )

||| Binding information. This may contain the sort, name, multiplicity, implicity,
||| etc. of a variable that is being bound.
data CBind
  MkCBind : CSort Name -- CBind
end

unCBind : CBind -- CSort Name
unCBind = match(MkCBind -> id)

cbind->csort : CBind -- CSort
cbind->csort = unCBind drop

cbind->name : CBind -- Name
cbind->name = unCBind nip

cbind= : CBind CBind -- Bool
cbind= = both(cbind->csort) csort=

||| Separate name spaces for each core name.
data CSpace
  CSpPkg : Pkg -- CSpace
  CSpMod : Mod -- CSpace
end

||| Convert CSpace into a string for printing. This is
||| meant for easy reading, not for (de)serialization.
|||
||| See also: `cspace->sexp`
cspace->str : CSpace -- Str
cspace->str =
  match

||| Convert CSpace into an S-expression for (de)serialization.
|||
||| See also: `cspace->str`
cspace->sexp : CSpace -- Sexp
cspace->sexp =
  match

||| A Core Name is a Name bundled with its
||| syntactic sort and its space. This makes
||| each name _unique_.
data CName
  MkCName : CSort CSpace Name -- CName
end

||| Deconstructo CName
unCName : CName -- CSort CSpace Name
unCName = match(MkCName -> id)

||| Get the CSort of a CName.
cname->csort : CName -- CSort
cname->csort = unCName drop2

||| Get the CSpace of a CName.
cname->cspace : CName -- CSpace
cname->cspace = unCName drop nip

||| Get the underlying Name of a CName.
cname->name : CName -- Name
cname->name = unCName dip(drop2)

||| Convert a CName into a Str. This is meant for easy reading,
||| not for (de)serialization.
|||
||| See also: `cname->sexp`
cname->str : CName -- Str
cname->str = unCName dip2(csort->str "::" <>) dip(cspace->str "::" <> <>) name->str <>


data CSort
  CSType : CSort
  CSData : CSort
  CSWord : CSort
end

data CKind(x)
  CKType : CKind(x)
  CKData : CType(x) -- CKind(x)
  CKWord : CType(x) CType(x) -- CKind(x)
end

data CTerm(x)
  CTType : CType(x) -- CTerm(x)
  CTData : CData(x) -- CTerm(x)
  CTWord : CWord(x) -- CTerm(x)
end

data CType(x)
  CTVar : x -- CType(x)
  CTApp : CName List(CTerm(x)) -- CType(x)
  CTAny : CBind CKind(x) CType(CSucc(x)) -- CType(x)
  CTNil : CType(x)
  CTCat : CType(x) CType(x) -- CType(x)
  CTInt : CType(x)
  CTStr : CType(x)
end

data CData(x)
  CDVar : x -- CData(x)
  CDApp : CName List(CTerm(x)) -- CData(x)
  CDNil : CData(x)
  CDCat : CData(x) CData(x) -- CData(x)
  CDInt : Int -- CData(x)
  CDStr : Str -- CData(x)
end

data CWord(x)
  CWVar : x -- CType(x)
  CWApp : CName List(CTerm(x)) -- CWord(x)
  CWPush : CData(x) -- CWord(x)
  CWId : CWord(x)
  CWCp : CWord(x) CWord(x) -- CWord(x)
  CWSym : CWord(x)
  CWDipL : CWord(x) -- CWord(x)
  CWDipR : CWord(x) -- CWord(x)
  CWAssocL : CWord(x)
  CWAssocR : CWord(x)
end

data CCtx(x)
  CCZ' (f: CZero -- x, g: x -- CZero) : CCtx(x)
  CCS' (f: CSucc(y) -- x, g: x -- CSucc(y)) : CCtx(y) CBind CKind(y) -- CCtx(x)
end

data CDef
  MkCDef : CCtx(x) CKind(x) Maybe(CTerm(x))
end

data CEnv
  MkCEnv : Map(CName, CDef) -- CEnv
end


