
import base/unit
import base/maybe
import base/void
import base/map
import base/result
import base/int
import base/str
import base/sexp
import base/list

import mirth/mod
import mirth/name
import mirth/loc
import mirth/syntax

export mirth/core
  type Name
  type Either(a,b)

  type CZero
  type CSucc(x)

  type CEnv
  type CDef
  type CSpace
  type CSymbol
  type CImplicit
  type CBindInfo
  type CSort

  type CBind(x)
  type CKind(x)
  type CTerm(x)
  type CStackType(x)
  type CValueType(x)
  type CStack(x)
  type CValue(x)
  type CWord(x)
  type CArgs(x)

  cbMap (f: *g a -- *g b) : *g CBind(a) -- *g CBind(b)
  ckMap (f: *g a -- *g b) : *g CKind(a) -- *g CKind(b)
  ctMap (f: *g a -- *g b) : *g CTerm(a) -- *g CTerm(b)
  cstMap (f: *g a -- *g b) : *g CStackType(a) -- *g CStackType(b)
  cvtMap (f: *g a -- *g b) : *g CValueType(a) -- *g CValueType(b)
  csMap (f: *g a -- *g b) : *g CStack(a) -- *g CStack(b)
  cvMap (f: *g a -- *g b) : *g CValue(a) -- *g CValue(b)
  cwMap (f: *g a -- *g b) : *g CWord(a) -- *g CWord(b)
  caMap (f: *g a -- *g b) : *g CArgs(a) -- *g CArgs(b)

  cbSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CBind(a) -- *g CBind(b)
  ckSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CKind(a) -- *g CKind(b)
  ctSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CTerm(a) -- *g CTerm(b)
  cstSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CStackType(a) -- *g CStackType(b)
  cvtSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CValueType(a) -- *g CValueType(b)
  csSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CStack(a) -- *g CStack(b)
  cvSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CValue(a) -- *g CValue(b)
  cwSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CWord(a) -- *g CWord(b)
  caSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CArgs(a) -- *g CArgs(b)

end

||| Empty type to represent the free variables that can appear in a closed term.
data CZero
end

czero : *a CZero -- *b
czero = match

||| Successor type, to represent the free variables that can appear inside a lambda.
data CSucc(x)
  Z : CSucc(x)
  S : x -- CSucc(x)
end

csucc(f: *a -- *b, g: *a x -- *b) : *a CSucc(x) -- *b
csucc(f, g) =
  match(
    Z -> f,
    S -> g
  )

data CImplicit
  MkCImplicit : Bool -- CImplicit
end

||| Separate name spaces for each core name.
data CSpace
  CSpPrim : CSpace
  CSpMod : Mod -- CSpace
  CSpPkg : Pkg -- CSpace
  CSpIface : Interface -- CSpace
end

||| A Core Symbol is a Name bundled with its
||| name space. This makes each name _unique_.
data CSymbol
  MkCSymbol : CSpace Name -- CSymbol
end

data CSort
  CSLambda : CSort CSort -- CSort
  CSStackType : CSort
  CSValueType : CSort
  CSStack : CSort
  CSValue : CSort
  CSWord : CSort
end

data CKind(x)
  CKLambda : CBind(x) CKind(CSucc(x)) -- CKind(x)
  CKStackType : CKind(x)
  CKValueType : CKind(x)
  CKStack : CStackType(x) -- CKind(x)
  CKValue : CValueType(x) -- CKind(x)
  CKWord : CStackType(x) CStackType(x) -- CKind(x)
end

data CTerm(x)
  CTLambda : CBind(x) CTerm(CSucc(x)) -- CTerm(x)
  CTStackType : CStackType(x) -- CTerm(x)
  CTValueType : CValueType(x) -- CTerm(x)
  CTStack : CStack(x) -- CTerm(x)
  CTValue : CValue(x) -- CTerm(x)
  CTWord : CStackType(x) CWord(x) -- CTerm(x)
end

data CStackType(x)
  CSTVar  : x CArgs(x) -- CStackType(x)
  CSTNil  : CStackType(x)
  CSTCons : CStackType(x) CValueType(x) -- CStackType(x)
end

data CValueType(x)
  CVTVar : x CArgs(x) -- CValueType(x)
  CVTSym : CSymbol CArgs(x) -- CValueType(x)
end

data CStack(x)
  CSVar : x CArgs(x) -- CStack(x)
  CSNil : CStack(x)
  CSCons : CStack(x) CValue(x) -- CStack(x)
  CSTail : CStack(x) -- CStack(x)
  CSRun : CStack(x) CWord(x) -- CStack(x)
end

data CValue(x)
  CVVar : x CArgs(x) -- CValue(x)
  CVSym : CSymbol CArgs(x) -- CValue(x)
  CVHead : CStack(x) -- CValue(x)
end

data CWord(x)
  CWVar : x CArgs(x) -- CWord(x)
  CWSym : CSymbol CArgs(x) -- CWord(x)
  CWPush : CValue(x) -- CWord(x)
end

||| Argument lists.
data CArgs(x)
  MkCArgs : List(CTerm(x)) -- CArgs(x)
end

unCArgs : CArgs(x) -- List(CTerm(x))
unCArgs = match(MkCArgs -> id)

caNil : CArgs(x)
caNil = nil MkCArgs

caConsL : CTerm(x) CArgs(x) -- CArgs(x)
caConsL = unCArgs consL MkCArgs

caConsR : CArgs(x) CTerm(x) -- CArgs(x)
caConsR = dip(unCArgs) consR MkCArgs

caCat : CArgs(x) CArgs(x) -- CArgs(x)
caCat = dip(unCArgs) unCArgs ++ MkCArgs

caMatchL (
  f: *a -- *b,
  g: *a CTerm(x) CArgs(x) -- *b
) : *a CArgs(x) -- *b

caMatchR (
  f: *a -- *b,
  g: *a CArgs(x) CTerm(x) -- *b
) : *a CArgs(x) -- *b

caMatchL(f,g) = unCArgs lmatchL(f, MkCArgs g)
caMatchR(f,g) = unCArgs lmatchR(f, dip(MkCArgs) g)

||| Binding info, such as name, implicit/explicit/auto, etc.
data CBindInfo
  MkCBindInfo : CImplicit Name -- CBindInfo
end

||| A binding, which includes the kind and other binding info.
data CBind(x)
  MkCBind : CBindInfo CKind(x) -- CBind(x)
end

unCBind : CBind(x) -- CBindInfo CKind(x)
unCBind = match(MkCBind -> id)

cbind->ckind : CBind(x) -- CKind(x)
cbind->ckind = unCBind nip

data CDef
  MkCDef : CKind(CZero) Maybe(CTerm(CZero)) -- CDef
end

data CEnv
  MkCEnv : Map(CSymbol, CDef) -- CEnv
end

cbind->csort : CBind(x) -- CSort
ckind->csort : CKind(x) -- CSort
cbind->csort = cbind->ckind ckind->csort
ckind->csort =
  match(
    CKLambda -> dip(cbind->csort) ckind->csort CSLambda,
    CKStackType -> CSStackType,
    CKValueType -> CSValueType,
    CKStack -> drop CSStack,
    CKValue -> drop CSValue,
    CKWord -> drop2 CSWord
  )

cterm->csort : CTerm(x) -- CSort
cterm->csort =
  match(
    CTLambda -> dip(cbind->csort) cterm->csort CSLambda,
    CTStackType -> drop CSStackType,
    CTValueType -> drop CSValueType,
    CTStack -> drop CSStack,
    CTValue -> drop CSValue,
    CTWord -> drop2 CSWord
  )

undefined : *a -- *b
undefined = "undefined" _prim_unsafe_panic

unexpected(m: Str) : *a -- *b
unexpected(m) = "unexpected: " m <> _prim_unsafe_panic

cbMap (f: *g a -- *g b) : *g CBind(a) -- *g CBind(b)
ckMap (f: *g a -- *g b) : *g CKind(a) -- *g CKind(b)
ctMap (f: *g a -- *g b) : *g CTerm(a) -- *g CTerm(b)
cstMap (f: *g a -- *g b) : *g CStackType(a) -- *g CStackType(b)
cvtMap (f: *g a -- *g b) : *g CValueType(a) -- *g CValueType(b)
csMap (f: *g a -- *g b) : *g CStack(a) -- *g CStack(b)
cvMap (f: *g a -- *g b) : *g CValue(a) -- *g CValue(b)
cwMap (f: *g a -- *g b) : *g CWord(a) -- *g CWord(b)
caMap (f: *g a -- *g b) : *g CArgs(a) -- *g CArgs(b)

cbMap(f) =
  match(
    MkCBind -> dip'(ckMap(f)) MkCBind
  )
ckMap(f) =
  match(
    CKLambda ->
      dip(cbMap(f))
      dip'(ckMap(csucc(Z, f S)))
      CKLambda,
    CKStackType -> CKStackType,
    CKValueType -> CKValueType,
    CKStack -> cstMap(f) CKStack,
    CKValue -> cvtMap(f) CKValue,
    CKWord -> dip(cstMap(f)) dip'(cstMap(f)) CKWord
  )
ctMap(f) =
  match(
    CTLambda ->
      dip(cbMap(f))
      dip'(ctMap(csucc(Z, f S)))
      CTLambda,
    CTStackType -> cstMap(f) CTStackType,
    CTValueType -> cvtMap(f) CTValueType,
    CTStack -> csMap(f) CTStack,
    CTValue -> cvMap(f) CTValue,
    CTWord -> dip(cstMap(f)) dip'(cwMap(f)) CTWord
  )
cstMap(f) =
  match(
    CSTVar -> dip(f) dip'(caMap(f)) CSTVar,
    CSTNil -> CSTNil,
    CSTCons -> dip(cstMap(f)) dip'(cvtMap(f)) CSTCons
  )
cvtMap(f) =
  match(
    CVTVar -> dip(f) dip'(caMap(f)) CVTVar,
    CVTSym -> dip'(caMap(f)) CVTSym
  )
csMap(f) =
  match(
    CSVar -> dip(f) dip'(caMap(f)) CSVar,
    CSNil -> CSNil,
    CSCons -> dip(csMap(f)) dip'(cvMap(f)) CSCons,
    CSTail -> csMap(f) CSTail,
    CSRun -> dip(csMap(f)) dip'(cwMap(f)) CSRun
  )
cvMap(f) =
  match(
    CVVar -> dip(f) dip'(caMap(f)) CVVar,
    CVSym -> dip'(caMap(f)) CVSym,
    CVHead -> csMap(f) CVHead
  )
cwMap(f) =
  match(
    CWVar -> dip(f) dip'(caMap(f)) CWVar,
    CWSym -> dip'(caMap(f)) CWSym,
    CWPush -> cvMap(f) CWPush
  )
caMap(f) =
  unCArgs formap(ctMap(f)) MkCArgs

||| Return the top level variable for a given kind.
||| Note that core terms are always eta-expanded,
||| so the "zero" variable may be largish.
ctVarZ : CKind(x) -- CTerm(CSucc(x))
ctVarZaux : x CArgs(x) CKind(x) -- CTerm(x)

ctVarZ = ckMap(S) dip(Z caNil) ctVarZaux
ctVarZaux =
  match(
    CKLambda ->
      dip2(dip(S) caMap(S))
      dip(dup dip(rotr))
      dip(cbind->ckind ctVarZ caConsR)
      ctVarZaux
      CTLambda,
    CKStackType -> CSTVar CTStackType,
    CKValueType -> CVTVar CTValueType,
    CKStack -> drop CSVar CTStack,
    CKValue -> drop CVVar CTValue,
    CKWord -> drop rotr CWVar CTWord
  )

data Either(a,b)
  Left : a -- Either(a,b)
  Right : b -- Either(a,b)
end

either(f: *x a -- *y, g: *x b -- *y) : *x Either(a,b) -- *y
either(f,g) = match(Left -> f, Right -> g)

cbSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CBind(a) -- *g CBind(b)
ckSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CKind(a) -- *g CKind(b)
ctSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CTerm(a) -- *g CTerm(b)
cstSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CStackType(a) -- *g CStackType(b)
cvtSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CValueType(a) -- *g CValueType(b)
csSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CStack(a) -- *g CStack(b)
cvSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CValue(a) -- *g CValue(b)
cwSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CWord(a) -- *g CWord(b)
caSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CArgs(a) -- *g CArgs(b)

ctApply : CTerm(x) CArgs(x) -- CTerm(x)
ctApplyAux(f: *g y -- *g Either(x, CTerm(x))) : *g CTerm(y) CArgs(x) -- *g CTerm(x)

ctApply = ctApplyAux(Left)
ctApplyAux(f) =
  caMatchL(
    ctSubst(f),
    rotl match(
      CTLambda -> nip swap ctApplyAux(csucc(dup Right, dip'(f))) nip,
      _ -> unexpected("attempt to apply to non-lambda")
    )
  )

cbSubst(f) =
  match(
    MkCBind -> dip'(ckSubst(f)) MkCBind
  )

ckSubst(f) =
  match(
    CKLambda ->
      dip(cbSubst(f))
      ckSubst(csucc(Z Left, dip'(f) either(S Left, ctMap(S) Right)))
      CKLambda,
    CKStackType -> CKStackType,
    CKValueType -> CKValueType,
    CKStack -> cstSubst(f) CKStack,
    CKValue -> cvtSubst(f) CKValue,
    CKWord -> dip(cstSubst(f)) dip'(cstSubst(f)) CKWord
  )

ctSubst(f) =
  match(
    CTLambda ->
      dip(cbSubst(f))
      ctSubst(csucc(Z Left, dip'(f) either(S Left, ctMap(S) Right)))
      CTLambda,
    CTStackType -> cstSubst(f) CTStackType,
    CTValueType -> cvtSubst(f) CTValueType,
    CTStack -> csSubst(f) CTStack,
    CTValue -> cvSubst(f) CTValue,
    CTWord -> dip(cstSubst(f)) dip'(cwSubst(f)) CTWord
  )

cstSubst(f) =
  match(
    CSTVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CSTVar,
        swap ctApply match(
          CTStackType -> id,
          _ -> unexpected("bad substitution")
        )
      ),
    CSTNil -> CSTNil,
    CSTCons -> dip(cstSubst(f)) dip'(cvtSubst(f)) CSTCons
  )

cvtSubst(f) =
  match(
    CVTVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CVTVar,
        swap ctApply match(
          CTValueType -> id,
          _ -> unexpected("bad substitution")
        )
      ),
    CVTSym -> dip'(caSubst(f)) CVTSym
  )

csSubst(f) =
  match(
    CSVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CSVar,
        swap ctApply match(
          CTStack -> id,
          _ -> unexpected("bad substitution")
        )
      ),
    CSNil -> CSNil,
    CSCons -> dip(csSubst(f)) dip'(cvSubst(f)) CSCons,
    CSRun -> dip(csSubst(f)) dip'(cwSubst(f)) CSRun,
    CSTail -> csSubst(f) CSTail
  )

cvSubst(f) =
  match(
    CVVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CVVar,
        swap ctApply match(
          CTValue -> id,
          _ -> unexpected("bad substitution")
        )
      ),
    CVSym -> dip'(caSubst(f)) CVSym,
    CVHead -> csSubst(f) CVHead
  )

cwSubst(f) =
  match(
    CWVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CWVar,
        swap ctApply match(
          CTWord -> nip,
          _ -> unexpected("bad substitution")
        )
      ),
    CWSym -> dip'(caSubst(f)) CWSym,
    CWPush -> cvSubst(f) CWPush
  )

caSubst(f) = unCArgs formap(ctSubst(f)) MkCArgs

######################
# Core Type Checking #
######################

data CCtx(x)
  CCZ@(f: x -- CZero, g: CZero -- x) : CCtx(x)
  CCS@(f: x -- CSucc(y), g: CSucc(y) -- x) : CCtx(y) CBind(y) -- CCtx(x)
end

CCZ : CCtx(CZero)
CCZ = CCZ@(id,id)

CCS : CCtx(x) CBind(x) -- CCtx(CSucc(x))
CCS = CCS@(id,id)

ccLookup : CCtx(x) x -- CBind(x)
ccLookup =
  swap match(
    CCZ@(f,g) -> f czero,
    CCS@(f,g) ->
      rotl f csucc(
        nip,
        nip ccLookup
      ) cbMap(S g)
  )

data CError
end

data CMonad(x,t)
  MkCMonad(f: CEnv CCtx(x) m -- CEnv CCtx(x) Result(CError, t)) : m -- CMonad(x,t)
end

cmRun : CEnv CCtx(x) CMonad(x,t) -- CEnv CCtx(x) Result(CError, t)
cmRun = match(MkCMonad(f) -> f)

cmPure : t -- CMonad(x,t)
cmPure = MkCMonad(ok)

cmPure2 : a b -- CMonad(x,a) CMonad(x,b)
cmPure2 = dip(cmPure) cmPure

cmFail : CError -- CMonad(x,t)
cmFail = MkCMonad(err)

cmCtx : CMonad(x, CCtx(x))
cmCtx = unit MkCMonad(drop dup ok)

cmEnv : CMonad(x, CEnv)
cmEnv = unit MkCMonad(drop over ok)

cmMap(f: a -- b) : CMonad(x,a) -- CMonad(x,b)
cmMap(f) = MkCMonad(cmRun rmap(f))

cmMap2(f: a b -- c) : CMonad(x,a) CMonad(x,b) -- CMonad(x,c)
cmMap2(f) =
  pack2 MkCMonad(
    unpack2 dip(cmRun) swap
    result(
      nip err,
      dip(cmRun) swap
      result(
        nip err,
        f ok
      )
    )
  )

cmMap3(f: a b c -- d) : CMonad(x,a) CMonad(x,b) CMonad(x,c) -- CMonad(x,d)
cmMap3(f) = cmMap2(pack2) cmMap2(unpack2 f)

cmMap4(f: a b c d -- e) : CMonad(x,a) CMonad(x,b) CMonad(x,c) CMonad(x,d) -- CMonad(x,e)
cmMap4(f) = cmMap2(pack2) cmMap3(unpack2 f)

cmBind(f: a -- CMonad(x,b)) : CMonad(x,a) -- CMonad(x,b)
cmBind(f) =
  MkCMonad(
    cmRun
    result(
      err,
      f cmRun
    )
  )

cmBind2(f: a b -- CMonad(x,c)) : CMonad(x,a) CMonad(x,b) -- CMonad(x,c)
cmBind2(f) = cmMap2(pack2) cmBind(unpack2 f)

cmBind3(f: a b c -- CMonad(x,d)) : CMonad(x,a) CMonad(x,b) CMonad(x,c) -- CMonad(x,d)
cmBind3(f) = cmMap3(pack3) cmBind(unpack3 f)

cmBind4(f: a b c d -- CMonad(x,e)) : CMonad(x,a) CMonad(x,b) CMonad(x,c) CMonad(x,d) -- CMonad(x,e)
cmBind4(f) = cmMap4(pack4) cmBind(unpack4 f)

cmUnit : CMonad(x, Unit)
cmUnit = unit cmPure

cmVoid : CMonad(x,a) -- CMonad(x, Unit)
cmVoid = cmMap(drop unit)

cmVoid2 : CMonad(x,a) CMonad(x,b) -- CMonad(x, Unit)
cmVoid2 = cmMap2(drop2 unit)

cmSucc : CBind(x) CMonad(CSucc(x), t) -- CMonad(x, t)
cmSucc = pack2 MkCMonad(dip(tuck) unpack2 dip(CCS) cmRun dip(drop swap))

ckCheck : CKind(x) -- CMonad(x, Unit)
cstCheck : CStackType(x) -- CMonad(x, Unit)
cvtCheck : CValueType(x) -- CMonad(x, Unit)
ctCheck : CTerm(x) CKind(x) -- CMonad(x, Unit)
csCheck : CStack(x) CStackType(x) -- CMonad(x, Unit)
cvCheck : CValue(x) CValueType(x) -- CMonad(x, Unit)
cwCheck : CWord(x) CStackType(x) CStackType(x) -- CMonad(x, Unit)

ckCheckEq : CKind(x) CKind(x) -- CMonad(x, Unit)
cstCheckEq : CStackType(x) CStackType(x) -- CMonad(x, Unit)
cvtCheckEq : CValueType(x) CValueType(x) -- CMonad(x, Unit)

ctInfer : CTerm(x) -- CMonad(x, CKind(x))
csInfer : CStack(x) -- CMonad(x, CStackType(x))
cvInfer : CValue(x) -- CMonad(x, CValueType(x))
cwInfer : CStackType(x) CWord(x) -- CMonad(x, CStackType(x))

caInfer : CKind(x) CArgs(x) -- CMonad(x, CKind(x))
caInferVar : x CArgs(x) -- CMonad(x, CKind(x))
caInferSym : CSymbol CArgs(x) -- CMonad(x, CKind(x))

cmExpectKLambda : CKind(x) -- CMonad(x, Pack(CKind(x) CKind(CSucc(x))))
cmExpectKStackType : CKind(x) -- CMonad(x, Unit)
cmExpectKValueType : CKind(x) -- CMonad(x, Unit)
cmExpectKStack : CKind(x) -- CMonad(x, CStackType(x))
cmExpectKValue : CKind(x) -- CMonad(x, CValueType(x))
cmExpectKWord : CKind(x) -- CMonad(x, Pack(CStackType(x) CStackType(x)))

cmExpectSTCons : CStackType(x) -- CMonad(x, Pack(CStackType(x) CValueType(x)))

ckCheck =
  match(
    CKLambda -> dip(dup dip(cbind->ckind ckCheck)) ckCheck cmSucc cmVoid2,
    CKStackType -> cmUnit,
    CKValueType -> cmUnit,
    CKStack -> cstCheck,
    CKValue -> cvtCheck,
    CKWord -> dip(cstCheck) cstCheck cmVoid2
  )

cstCheck =
  match(
    CSTVar -> caInferVar cmBind(cmExpectKStackType),
    CSTNil -> cmUnit,
    CSTCons -> dip(cstCheck) cvtCheck cmVoid2
  )

cvtCheck =
  match(
    CVTVar -> caInferVar cmBind(cmExpectKValueType),
    CVTSym -> caInferSym cmBind(cmExpectKValueType)
  )

ctCheck = dip(ctInfer) cmPure cmBind2(ckCheckEq)
csCheck = dip(csInfer) cmPure cmBind2(cstCheckEq)
cvCheck = dip(cvInfer) cmPure cmBind2(cvtCheckEq)
cwCheck = dip(swap cwInfer) cmPure cmBind2(cstCheckEq)

ctInfer =
  match(
    CTLambda ->
      dip(dup dip(cbind->ckind ckCheck))
      dip(dup dip(cmPure))
      ctInfer cmSucc
      cmMap3(CKLambda nip),
    CTStackType -> cstCheck cmMap(drop CKStackType),
    CTValueType -> cvtCheck cmMap(drop CKValueType),
    CTStack -> csInfer cmMap(CKStack),
    CTValue -> cvInfer cmMap(CKValue),
    CTWord ->
      dip(dup dip(cstCheck))
      dip(dup dip(cmPure))
      cwInfer cmMap3(CKWord nip)
  )

csInfer =
  match(
    CSVar -> caInferVar cmBind(cmExpectKStack),
    CSNil -> CSTNil cmPure,
    CSCons -> dip(csInfer) cvInfer cmMap2(CSTCons),
    CSTail -> csInfer cmBind(cmExpectSTCons cmMap(unpack2 drop)),
    CSRun -> dip(csInfer) cmPure cmBind2(cwInfer)
  )

cvInfer =
  match(
    CVVar -> caInferVar cmBind(cmExpectKValue),
    CVSym -> caInferSym cmBind(cmExpectKValue),
    CVHead -> csInfer cmBind(cmExpectSTCons cmMap(unpack2 nip))
  )

cwInfer =
  match(
    CWVar ->
      dip2(cmPure) caInferVar cmBind(cmExpectKWord)
      cmBind2(unpack2 dip(cstCheckEq) cmPure cmMap2(nip)),
    CWSym ->
      dip2(cmPure) caInferSym cmBind(cmExpectKWord)
      cmBind2(unpack2 dip(cstCheckEq) cmPure cmMap2(nip)),
    CWPush ->
      dip(cmPure) cvInfer cmMap2(CSTCons)
  )

