import base/result
import base/map
import base/set
import base/list
import base/sexp

import mirth/syntax
import mirth/mod
import mirth/loc

export mirth/core
  type L(t)
  type Result(e,v)
  type Set(t)
  type Sexp

  type CoreError
  type CoreInterface
  type CoreModule
  type CoreEnv
  type CoreDef
  type CoreDefType
  type CoreDefWord
  type CoreFlag
  type CoreCtx
  type CoreKind
  type CoreStack
  type CoreType
  type CoreWord
  type CoreSym
  type CoreVar

  coreError->str : CoreError -- Str

  mkCoreInterface : Interface CoreEnv -- CoreInterface
  unCoreInterface : CoreInterface -- Interface CoreEnv
  coreInterface->str : CoreInterface -- Str
  coreInterface->sexp : CoreInterface -- Sexp

  coreModuleNil : Mod -- CoreModule
  coreModule->str : CoreModule -- Str
  coreModule->sexp : CoreModule -- Sexp

  coreEnvNil : CoreEnv
  coreEnv->sexp : CoreEnv -- Sexp
  coreEnvSet : CoreEnv CoreSym CoreDef -- CoreEnv
  coreEnvGet : CoreEnv CoreSym -- Maybe(CoreDef)
  coreEnvHas : CoreEnv CoreSym -- Bool
  coreEnvGet? : CoreEnv CoreSym -- CoreEnv CoreSym Maybe(CoreDef)
  coreEnvHas? : CoreEnv CoreSym -- CoreEnv CoreSym Bool

  coreDefType : Set(CoreFlag) CoreDefType -- CoreDef
  coreDefWord : Set(CoreFlag) CoreDefWord -- CoreDef
  coreDefError : Set(CoreFlag) -- CoreDef
  coreDefMatch (
    onCoreDefType : *a Set(CoreFlag) CoreDefType -- *b,
    onCoreDefWord : *a Set(CoreFlag) CoreDefWord -- *b,
    onCoreDefError : *a Set(CoreFlag) -- *b
  ) : *a CoreDef -- *b
  coreDef->sexp : CoreDef -- Sexp

  coreDefTypeSig : CoreCtx -- CoreDefType
  coreDefTypeMatch (
    onCoreDefTypeSig : *a CoreCtx -- *b
  ) : *a CoreDefType -- *b
  coreDefType->sexp : CoreDefType -- Sexp

  coreDefWordMatch : *a CoreDefWord -- *b
  coreDefWord->sexp : CoreDefWord -- Sexp

  coreFlagTainted  : CoreFlag
  coreFlagImported : Interface -- CoreFlag
  coreFlag->sexp : CoreFlag -- Sexp

  coreCtxNil : CoreCtx
  coreCtxCons : CoreEnv CoreCtx CoreVar CoreKind -- CoreEnv Result(CoreError, CoreCtx)
  coreCtxHasPositional  : CoreCtx CoreVar -- Bool
  coreCtxHasPositional? : CoreCtx CoreVar -- CoreCtx CoreVar Bool
  coreCtx->sexp : CoreCtx -- Sexp

  coreKindStack : CoreKind
  coreKindType : CoreKind
  coreKindWord : CoreType -- CoreKind
  coreKind->sexp : CoreKind -- Sexp

  coreType->sexp : CoreType -- Sexp

  mkCoreSym : Name -- CoreSym
  unCoreSym : CoreSym -- Name
  coreSym->str : CoreSym -- Str
  coreSym->sexp : CoreSym -- Sexp

  mkCoreVar : Name -- CoreVar
  unCoreVar : CoreVar -- Name
  coreVar->str : CoreVar -- Str
end

||| A Core Error. These do not have locations attached, and
||| should be prevented by the elaborator where possible.
data CoreError
  mkCoreError : Str -- CoreError
end

coreError->str = match(mkCoreError -> id)

||| A Core Interface is the core equivalent of an interface,
||| i.e. an export list. These are meant to be self-contained.
||| In practice this is just a wrapper over a CoreEnv that
||| can only contain type signatures and word signatures.
data CoreInterface
  ||| Construct the Core Interface.
  mkCoreInterface : Interface CoreEnv -- CoreInterface
end

||| Destruct the Core Interface.
unCoreInterface : CoreInterface -- Interface CoreEnv
unCoreInterface = match( mkCoreInterface -> id )

||| Show the Core interface as a string (via its sexp).
coreInterface->str = coreInterface->sexp sexp->str

||| Serialize a Core Interface into a Sexp.
coreInterface->sexp = $(
  unCoreInterface
  dip2(nil)
  dip2("core-interface" sexpAtom cons)
  dip(interface->str sexpAtom cons)
  coreEnv->sexp cons
  sexpList
)

||| A Core Module is the core equivalent of a module.
data CoreModule
  ||| Construct Core Module
  mkCoreModule : Mod CoreEnv -- CoreModule
end

||| Destruct Core Module
unCoreModule : CoreModule -- Mod CoreEnv
unCoreModule = match( mkCoreModule -> id )

||| Empty Core Module.
coreModuleNil : Mod -- CoreModule
coreModuleNil = coreEnvNil mkCoreModule

||| Show the Core Module as a string (via its sexp).
coreModule->str : CoreModule -- Str
coreModule->str = coreModule->sexp sexp->str

||| Serialize a Core Module into a Sexp.
coreModule->sexp : CoreModule -- Sexp
coreModule->sexp = $(
  unCoreModule
  dip2(nil)
  dip2("core-module" sexpAtom cons)
  dip(mod->str sexpAtom cons)
  coreEnv->sexp cons
  sexpList
)

||| A Core Env is the environment needed to evaluate terms.
||| This is built piece by piece from core declarations,
||| and arranged into a set of coherent bindings.
data CoreEnv
  mkCoreEnv : Map(CoreSym, CoreDef) -- CoreEnv
end

unCoreEnv : CoreEnv -- Map(CoreSym, CoreDef)
unCoreEnv = match( mkCoreEnv -> id )

||| Initial Core Env, devoid of bindings, not even builtins.
coreEnvNil : CoreEnv
coreEnvNil = mapNil mkCoreEnv

||| Set a binding.
coreEnvSet : CoreEnv CoreSym CoreDef -- CoreEnv
coreEnvSet = dip2(unCoreEnv) mapSet mkCoreEnv

||| Get a binding.
coreEnvGet : CoreEnv CoreSym -- Maybe(CoreDef)
coreEnvGet = dip(unCoreEnv) mapGet
coreEnvGet? = dup2 coreEnvGet

||| Has a binding.
coreEnvHas : CoreEnv CoreSym -- Bool
coreEnvHas = dip(unCoreEnv) mapHas
coreEnvHas? = dup2 coreEnvHas

  ||| Serialize a Core Env into a Sexp.
coreEnv->sexp : CoreEnv -- Sexp
coreEnv->sexp =
  match( mkCoreEnv ->
    dip(nil)
    dip("core-env" sexpAtom cons)
    map->sexp(coreSym->sexp, coreDef->sexp) cons
    sexpList
  )

||| A Core Def is what a global symbol is defined as. This may
||| be just a signature or a full blow definition.
data CoreDef
  coreDefType : Set(CoreFlag) CoreDefType -- CoreDef
  coreDefWord : Set(CoreFlag) CoreDefWord -- CoreDef
  coreDefError : Set(CoreFlag) -- CoreDef
end

coreDefMatch (
  onCoreDefType,
  onCoreDefWord,
  onCoreDefError
) = match(
  coreDefType -> onCoreDefType,
  coreDefWord -> onCoreDefWord,
  coreDefError -> onCoreDefError
)

coreDef->sexp : CoreDef -- Sexp
coreDef->sexp =
  match (
    coreDefType ->
      dip2(nil "core-def-type" sexpAtom cons)
      dip(set->sexp(coreFlag->sexp) cons)
      coreDefType->sexp cons sexpList,

    coreDefWord ->
      dip2(nil "core-def-word" sexpAtom cons)
      dip(set->sexp(coreFlag->sexp) cons)
      coreDefWord->sexp cons sexpList,

    coreDefError ->
      dip(nil "core-def-error" sexpAtom cons)
      set->sexp(coreFlag->sexp) cons sexpList
  )

||| A type binding.
data CoreDefType
  coreDefTypeSig : CoreCtx -- CoreDefType
end

coreDefTypeMatch (
  onCoreDefTypeSig
) = match(
  coreDefTypeSig -> onCoreDefTypeSig
)

coreDefType->sexp : CoreDefType -- Sexp
coreDefType->sexp =
  match(
    coreDefTypeSig ->
      dip(nil "core-def-type-sig" sexpAtom cons)
      coreCtx->sexp cons sexpList
  )

||| A word binding.
data CoreDefWord
end

coreDefWordMatch = match

coreDefWord->sexp : CoreDefWord -- Sexp
coreDefWord->sexp = match

||| Flags that may affect the interpretation of a definition.
data CoreFlag
  ||| Definition depends on an error, directly or indirectly, so likely to be bad.
  coreFlagTainted : CoreFlag

  ||| Definition imported from an interface.
  coreFlagImported : Interface -- CoreFlag
end

coreFlag->sexp : CoreFlag -- Sexp
coreFlag->sexp =
  match(
    coreFlagTainted -> "tainted" sexpAtom,
    coreFlagImported ->
      dip(nil "imported" sexpAtom cons)
      interface->str sexpAtom cons sexpList
  )

||| A Core Ctx is a context in which to evaluate terms.
||| A context defines kinds for all variables.
data CoreCtx
  mkCoreCtx : CoreCtx
end

CoreCtx.generate : CoreCtx
CoreCtx.generate = coreCtxNil

||| Create an empty context.
coreCtxNil : CoreCtx
coreCtxNil = mkCoreCtx

||| Add a positional argument to the context.
coreCtxCons : CoreEnv CoreCtx CoreVar CoreKind -- CoreEnv Result(CoreError, CoreCtx)
coreCtxCons = drop2 ok

||| Does a core ctx have a positional argument with a certain name?
coreCtxHasPositional : CoreCtx CoreVar -- Bool
coreCtxHasPositional = drop2 false

||| Does a core ctx have a positional argument with a certain name? (query)
coreCtxHasPositional? : CoreCtx CoreVar -- CoreCtx CoreVar Bool
coreCtxHasPositional? = dup2 coreCtxHasPositional
coreCtxHasPositional? drop == id

||| Serialize a CoreCtx into a Sexp.
coreCtx->sexp : CoreCtx -- Sexp
coreCtx->sexp = drop nil sexpList

||| Type of a binding in a kind context.
data CoreKind
  coreKindStack : CoreKind
  coreKindType : CoreKind
  coreKindWord : CoreType -- CoreKind
end

||| Serialize a CoreKind into a Sexp.
coreKind->sexp : CoreKind -- Sexp
coreKind->sexp =
  match(
    coreKindStack -> "stack-kind" sexpAtom,
    coreKindType -> "type-kind" sexpAtom,
    coreKindWord ->
      dip(nil)
      dip("word-kind" sexpAtom cons)
      coreType->sexp cons
      sexpList
  )

||| A type.
data CoreType
end

coreType->sexp : CoreType -- Sexp
coreType->sexp = match

||| A symbol for a global binding.
data CoreSym
  ||| Construct CoreSym
  mkCoreSym : Name -- CoreSym
end

||| Destruct CoreSym
unCoreSym : CoreSym -- Name
unCoreSym = match( mkCoreSym -> id )

||| Serialize a symbol as a sexp.
coreSym->sexp : CoreSym -- Sexp
coreSym->sexp = coreSym->str sexpAtom

||| Show the symbol as a string.
coreSym->str : CoreSym -- Str
coreSym->str = unCoreSym name->str

||| A variable for a local binding.
data CoreVar
  ||| Construct CoreVar
  mkCoreVar : Name -- CoreVar
end

CoreVar.generate : Str -- CoreVar
CoreVar.generate = mkName mkCoreVar

||| Destruct CoreVar
unCoreVar : CoreVar -- Name
unCoreVar = match( mkCoreVar -> id )

||| Show the variable as a string.
coreVar->str : CoreVar -- Str
coreVar->str = unCoreVar name->str

