
import base/unit
import base/maybe
import base/void
import base/map
import base/result
import base/int
import base/str
import base/sexp
import base/list

import mirth/mod
import mirth/name
import mirth/loc
import mirth/syntax

export mirth/core
  type Name
  type Either(a,b)

  type CZero
  type CSucc(x)

  type CEnv
  type CDef
  type CSpace
  type CSymbol
  type CImplicit
  type CBindInfo
  type CSort

  type CBind(x)
  type CKind(x)
  type CTerm(x)
  type CStackType(x)
  type CValueType(x)
  type CStack(x)
  type CValue(x)
  type CWord(x)
  type CArgs(x)

  cbMap (f: *g a -- *g b) : *g CBind(a) -- *g CBind(b)
  ckMap (f: *g a -- *g b) : *g CKind(a) -- *g CKind(b)
  ctMap (f: *g a -- *g b) : *g CTerm(a) -- *g CTerm(b)
  cstMap (f: *g a -- *g b) : *g CStackType(a) -- *g CStackType(b)
  cvtMap (f: *g a -- *g b) : *g CValueType(a) -- *g CValueType(b)
  csMap (f: *g a -- *g b) : *g CStack(a) -- *g CStack(b)
  cvMap (f: *g a -- *g b) : *g CValue(a) -- *g CValue(b)
  cwMap (f: *g a -- *g b) : *g CWord(a) -- *g CWord(b)
  caMap (f: *g a -- *g b) : *g CArgs(a) -- *g CArgs(b)

  cbSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CBind(a) -- *g CBind(b)
  ckSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CKind(a) -- *g CKind(b)
  ctSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CTerm(a) -- *g CTerm(b)
  cstSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CStackType(a) -- *g CStackType(b)
  cvtSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CValueType(a) -- *g CValueType(b)
  csSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CStack(a) -- *g CStack(b)
  cvSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CValue(a) -- *g CValue(b)
  cwSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CWord(a) -- *g CWord(b)
  caSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CArgs(a) -- *g CArgs(b)

end

||| Empty type to represent the free variables that can appear in a closed term.
data CZero
end

czero : *a CZero -- *b
czero = match

||| Successor type, to represent the free variables that can appear inside a lambda.
data CSucc(x)
  Z : CSucc(x)
  S : x -- CSucc(x)
end

csucc(f: *a -- *b, g: *a x -- *b) : *a CSucc(x) -- *b
csucc(f, g) =
  match(
    Z -> f,
    S -> g
  )

data CImplicit
  MkCImplicit : Bool -- CImplicit
end

||| Separate name spaces for each core name.
data CSpace
  CSpPrim : CSpace
  CSpMod : Mod -- CSpace
  CSpPkg : Pkg -- CSpace
  CSpIface : Interface -- CSpace
end

||| A Core Symbol is a Name bundled with its
||| name space. This makes each name _unique_.
data CSymbol
  MkCSymbol : CSpace Name -- CSymbol
end

data CSort
  CSLambda : CSort CSort -- CSort
  CSStackType : CSort
  CSValueType : CSort
  CSStack : CSort
  CSValue : CSort
  CSWord : CSort
end

data CKind(x)
  CKLambda : CBind(x) CKind(CSucc(x)) -- CKind(x)
  CKStackType : CKind(x)
  CKValueType : CKind(x)
  CKStack : CStackType(x) -- CKind(x)
  CKValue : CValueType(x) -- CKind(x)
  CKWord : CStackType(x) CStackType(x) -- CKind(x)
end

data CTerm(x)
  CTLambda : CBind(x) CTerm(CSucc(x)) -- CTerm(x)
  CTStackType : CStackType(x) -- CTerm(x)
  CTValueType : CValueType(x) -- CTerm(x)
  CTStack : CStack(x) -- CTerm(x)
  CTValue : CValue(x) -- CTerm(x)
  CTWord : CStackType(x) CWord(x) -- CTerm(x)
end

data CStackType(x)
  CSTVar  : x CArgs(x) -- CStackType(x)
  CSTNil  : CStackType(x)
  CSTCons : CStackType(x) CValueType(x) -- CStackType(x)
end

data CValueType(x)
  CVTVar : x CArgs(x) -- CValueType(x)
  CVTSym : CSymbol CArgs(x) -- CValueType(x)
end

data CStack(x)
  CSVar : x CArgs(x) -- CStack(x)
  CSNil : CStack(x)
  CSCons : CStack(x) CValue(x) -- CStack(x)
  CSTail : CStack(x) -- CStack(x)
  CSRun : CStack(x) CWord(x) -- CStack(x)
end

data CValue(x)
  CVVar : x CArgs(x) -- CValue(x)
  CVSym : CSymbol CArgs(x) -- CValue(x)
  CVHead : CStack(x) -- CValue(x)
end

data CWord(x)
  CWVar : x CArgs(x) -- CWord(x)
  CWSym : CSymbol CArgs(x) -- CWord(x)
  CWId : CWord(x)
  CWCp : CWord(x) CWord(x) -- CWord(x)
  CWPush : CValue(x) -- CWord(x)
  CWSwap : CWord(x)
  CWDrop : CWord(x)
  CWDup : CWord(x)
  CWDip : CWord(x) -- CWord(x)
end

||| Argument lists.
data CArgs(x)
  MkCArgs : List(CTerm(x)) -- CArgs(x)
end

unCArgs : CArgs(x) -- List(CTerm(x))
unCArgs = match(MkCArgs -> id)

CANil : CArgs(x)
CANil = nil MkCArgs

CAConsL : CTerm(x) CArgs(x) -- CArgs(x)
CAConsL = unCArgs consL MkCArgs

CAConsR : CArgs(x) CTerm(x) -- CArgs(x)
CAConsR = dip(unCArgs) consR MkCArgs

CACat : CArgs(x) CArgs(x) -- CArgs(x)
CACat = dip(unCArgs) unCArgs ++ MkCArgs

caMatchL (
  f: *a -- *b,
  g: *a CTerm(x) CArgs(x) -- *b
) : *a CArgs(x) -- *b

caMatchR (
  f: *a -- *b,
  g: *a CArgs(x) CTerm(x) -- *b
) : *a CArgs(x) -- *b

caMatchL(f,g) = unCArgs lmatchL(f, MkCArgs g)
caMatchR(f,g) = unCArgs lmatchR(f, dip(MkCArgs) g)

||| Binding info, such as name, implicit/explicit/auto, etc.
data CBindInfo
  MkCBindInfo : CImplicit Name -- CBindInfo
end

||| A binding, which includes the kind and other binding info.
data CBind(x)
  MkCBind : CBindInfo CKind(x) -- CBind(x)
end

unCBind : CBind(x) -- CBindInfo CKind(x)
unCBind = match(MkCBind -> id)

cbind->ckind : CBind(x) -- CKind(x)
cbind->ckind = unCBind nip

cbind->csort : CBind(x) -- CSort
ckind->csort : CKind(x) -- CSort
cbind->csort = cbind->ckind ckind->csort
ckind->csort =
  match(
    CKLambda -> dip(cbind->csort) ckind->csort CSLambda,
    CKStackType -> CSStackType,
    CKValueType -> CSValueType,
    CKStack -> drop CSStack,
    CKValue -> drop CSValue,
    CKWord -> drop2 CSWord
  )

cterm->csort : CTerm(x) -- CSort
cterm->csort =
  match(
    CTLambda -> dip(cbind->csort) cterm->csort CSLambda,
    CTStackType -> drop CSStackType,
    CTValueType -> drop CSValueType,
    CTStack -> drop CSStack,
    CTValue -> drop CSValue,
    CTWord -> drop2 CSWord
  )

undefined : *a -- *b
undefined = "undefined" _prim_unsafe_panic

unexpected(m: Str) : *a -- *b
unexpected(m) = "unexpected: " m <> _prim_unsafe_panic

cbMap (f: *g a -- *g b) : *g CBind(a) -- *g CBind(b)
ckMap (f: *g a -- *g b) : *g CKind(a) -- *g CKind(b)
ctMap (f: *g a -- *g b) : *g CTerm(a) -- *g CTerm(b)
cstMap (f: *g a -- *g b) : *g CStackType(a) -- *g CStackType(b)
cvtMap (f: *g a -- *g b) : *g CValueType(a) -- *g CValueType(b)
csMap (f: *g a -- *g b) : *g CStack(a) -- *g CStack(b)
cvMap (f: *g a -- *g b) : *g CValue(a) -- *g CValue(b)
cwMap (f: *g a -- *g b) : *g CWord(a) -- *g CWord(b)
caMap (f: *g a -- *g b) : *g CArgs(a) -- *g CArgs(b)

cbMap(f) =
  match(
    MkCBind -> dip'(ckMap(f)) MkCBind
  )
ckMap(f) =
  match(
    CKLambda ->
      dip(cbMap(f))
      dip'(ckMap(csucc(Z, f S)))
      CKLambda,
    CKStackType -> CKStackType,
    CKValueType -> CKValueType,
    CKStack -> cstMap(f) CKStack,
    CKValue -> cvtMap(f) CKValue,
    CKWord -> dip(cstMap(f)) dip'(cstMap(f)) CKWord
  )
ctMap(f) =
  match(
    CTLambda ->
      dip(cbMap(f))
      dip'(ctMap(csucc(Z, f S)))
      CTLambda,
    CTStackType -> cstMap(f) CTStackType,
    CTValueType -> cvtMap(f) CTValueType,
    CTStack -> csMap(f) CTStack,
    CTValue -> cvMap(f) CTValue,
    CTWord -> dip(cstMap(f)) dip'(cwMap(f)) CTWord
  )
cstMap(f) =
  match(
    CSTVar -> dip(f) dip'(caMap(f)) CSTVar,
    CSTNil -> CSTNil,
    CSTCons -> dip(cstMap(f)) dip'(cvtMap(f)) CSTCons
  )
cvtMap(f) =
  match(
    CVTVar -> dip(f) dip'(caMap(f)) CVTVar,
    CVTSym -> dip'(caMap(f)) CVTSym
  )
csMap(f) =
  match(
    CSVar -> dip(f) dip'(caMap(f)) CSVar,
    CSNil -> CSNil,
    CSCons -> dip(csMap(f)) dip'(cvMap(f)) CSCons,
    CSTail -> csMap(f) CSTail,
    CSRun -> dip(csMap(f)) dip'(cwMap(f)) CSRun
  )
cvMap(f) =
  match(
    CVVar -> dip(f) dip'(caMap(f)) CVVar,
    CVSym -> dip'(caMap(f)) CVSym,
    CVHead -> csMap(f) CVHead
  )
cwMap(f) =
  match(
    CWVar -> dip(f) dip'(caMap(f)) CWVar,
    CWSym -> dip'(caMap(f)) CWSym,
    CWId -> CWId,
    CWCp -> dip(cwMap(f)) dip'(cwMap(f)) CWCp,
    CWPush -> cvMap(f) CWPush,
    CWSwap -> CWSwap,
    CWDrop -> CWDrop,
    CWDup -> CWDup,
    CWDip -> cwMap(f) CWDip
  )
caMap(f) =
  unCArgs formap(ctMap(f)) MkCArgs

||| Return the top level variable for a given kind.
||| Note that core terms are always eta-expanded,
||| so the "zero" variable may be largish.
ctVarZ : CKind(x) -- CTerm(CSucc(x))
ctVarZaux : x CArgs(x) CKind(x) -- CTerm(x)

ctVarZ = ckMap(S) dip(Z CANil) ctVarZaux
ctVarZaux =
  match(
    CKLambda ->
      dip2(dip(S) caMap(S))
      dip(dup dip(rotr))
      dip(cbind->ckind ctVarZ CAConsR)
      ctVarZaux
      CTLambda,
    CKStackType -> CSTVar CTStackType,
    CKValueType -> CVTVar CTValueType,
    CKStack -> drop CSVar CTStack,
    CKValue -> drop CVVar CTValue,
    CKWord -> drop rotr CWVar CTWord
  )

data Either(a,b)
  Left : a -- Either(a,b)
  Right : b -- Either(a,b)
end

either(f: *x a -- *y, g: *x b -- *y) : *x Either(a,b) -- *y
either(f,g) = match(Left -> f, Right -> g)

cbSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CBind(a) -- *g CBind(b)
ckSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CKind(a) -- *g CKind(b)
ctSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CTerm(a) -- *g CTerm(b)
cstSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CStackType(a) -- *g CStackType(b)
cvtSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CValueType(a) -- *g CValueType(b)
csSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CStack(a) -- *g CStack(b)
cvSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CValue(a) -- *g CValue(b)
cwSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CWord(a) -- *g CWord(b)
caSubst (f: *g a -- *g Either(b, CTerm(b))) : *g CArgs(a) -- *g CArgs(b)

ctApply : CTerm(x) CArgs(x) -- CTerm(x)
ctApplyAux(f: *g y -- *g Either(x, CTerm(x))) : *g CTerm(y) CArgs(x) -- *g CTerm(x)

ctApply = ctApplyAux(Left)
ctApplyAux(f) =
  caMatchL(
    ctSubst(f),
    rotl match(
      CTLambda -> nip swap ctApplyAux(csucc(dup Right, dip'(f))) nip,
      _ -> unexpected("attempt to apply to non-lambda")
    )
  )

cbSubst(f) =
  match(
    MkCBind -> dip'(ckSubst(f)) MkCBind
  )

ckSubst(f) =
  match(
    CKLambda ->
      dip(cbSubst(f))
      ckSubst(csucc(Z Left, dip'(f) either(S Left, ctMap(S) Right)))
      CKLambda,
    CKStackType -> CKStackType,
    CKValueType -> CKValueType,
    CKStack -> cstSubst(f) CKStack,
    CKValue -> cvtSubst(f) CKValue,
    CKWord -> dip(cstSubst(f)) dip'(cstSubst(f)) CKWord
  )

ctSubst(f) =
  match(
    CTLambda ->
      dip(cbSubst(f))
      ctSubst(csucc(Z Left, dip'(f) either(S Left, ctMap(S) Right)))
      CTLambda,
    CTStackType -> cstSubst(f) CTStackType,
    CTValueType -> cvtSubst(f) CTValueType,
    CTStack -> csSubst(f) CTStack,
    CTValue -> cvSubst(f) CTValue,
    CTWord -> dip(cstSubst(f)) dip'(cwSubst(f)) CTWord
  )

cstSubst(f) =
  match(
    CSTVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CSTVar,
        swap ctApply match(
          CTStackType -> id,
          _ -> unexpected("bad substitution")
        )
      ),
    CSTNil -> CSTNil,
    CSTCons -> dip(cstSubst(f)) dip'(cvtSubst(f)) CSTCons
  )

cvtSubst(f) =
  match(
    CVTVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CVTVar,
        swap ctApply match(
          CTValueType -> id,
          _ -> unexpected("bad substitution")
        )
      ),
    CVTSym -> dip'(caSubst(f)) CVTSym
  )

csSubst(f) =
  match(
    CSVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CSVar,
        swap ctApply match(
          CTStack -> id,
          _ -> unexpected("bad substitution")
        )
      ),
    CSNil -> CSNil,
    CSCons -> dip(csSubst(f)) dip'(cvSubst(f)) CSCons,
    CSRun -> dip(csSubst(f)) dip'(cwSubst(f)) CSRun,
    CSTail -> csSubst(f) CSTail
  )

cvSubst(f) =
  match(
    CVVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CVVar,
        swap ctApply match(
          CTValue -> id,
          _ -> unexpected("bad substitution")
        )
      ),
    CVSym -> dip'(caSubst(f)) CVSym,
    CVHead -> csSubst(f) CVHead
  )

cwSubst(f) =
  match(
    CWVar ->
      dip(f) dip'(caSubst(f))
      swap either(
        swap CWVar,
        swap ctApply match(
          CTWord -> nip,
          _ -> unexpected("bad substitution")
        )
      ),
    CWSym -> dip'(caSubst(f)) CWSym,
    CWId -> CWId,
    CWCp -> dip(cwSubst(f)) dip'(cwSubst(f)) CWCp,
    CWPush -> cvSubst(f) CWPush,
    CWSwap -> CWSwap,
    CWDrop -> CWDrop,
    CWDup -> CWDup,
    CWDip -> cwSubst(f) CWDip
  )

caSubst(f) = unCArgs formap(ctSubst(f)) MkCArgs

######################
# Core Type Checking #
######################

data CCtx(x)
  CCZ@(f: x -- CZero, g: CZero -- x) : CCtx(x)
  CCS@(f: x -- CSucc(y), g: CSucc(y) -- x) : CCtx(y) CBind(y) -- CCtx(x)
end

CCZ : CCtx(CZero)
CCZ = CCZ@(id,id)

CCS : CCtx(x) CBind(x) -- CCtx(CSucc(x))
CCS = CCS@(id,id)

ccLookupVar : CCtx(x) x -- CBind(x)
ccLookupVar =
  swap match(
    CCZ@(f,g) -> f czero,
    CCS@(f,g) ->
      rotl f csucc(
        nip,
        nip ccLookupVar
      ) cbMap(S g)
  )

data CDef
  MkCDef : CKind(CZero) Maybe(CTerm(CZero)) -- CDef
end

unCDef : CDef -- CKind(CZero) Maybe(CTerm(CZero))
unCDef = match(MkCDef -> id)

cdef->ckind0 : CDef -- CKind(CZero)
cdef->ckind0 = unCDef drop

cdef->ckind : CDef -- CKind(x)
cdef->ckind = cdef->ckind0 ckMap(czero)

cdef->mcterm0 : CDef -- Maybe(CTerm(CZero))
cdef->mcterm0 = unCDef nip

cdef->mcterm : CDef -- Maybe(CTerm(x))
cdef->mcterm = cdef->mcterm0 mmap(ctMap(czero))

data CEnv
  MkCEnv : Map(CSymbol, CDef) -- CEnv
end

unCEnv : CEnv -- Map(CSymbol, CDef)
unCEnv = match(MkCEnv -> id)

ceLookupSym : CEnv CSymbol -- Maybe(CDef)
ceLookupSym = dip(unCEnv) mapGet

data CError
  CEUndeclaredSymbol : CSymbol -- CError
  CEExpectedForm : Str -- CError
  CERuntimeTypeError : Str -- CError
end

data CMonad(x,t)
  MkCMonad(f: CEnv CCtx(x) m -- CEnv CCtx(x) Result(CError, t)) : m -- CMonad(x,t)
end

cmRun : CEnv CCtx(x) CMonad(x,t) -- CEnv CCtx(x) Result(CError, t)
cmRun = match(MkCMonad(f) -> f)

cmPure : t -- CMonad(x,t)
cmPure = MkCMonad(ok)

cmPure2 : a b -- CMonad(x,a) CMonad(x,b)
cmPure2 = dip(cmPure) cmPure

cmFail : CError -- CMonad(x,t)
cmFail = MkCMonad(err)

cmMap(f: a -- b) : CMonad(x,a) -- CMonad(x,b)
cmMap(f) = MkCMonad(cmRun rmap(f))

cmMap2(f: a b -- c) : CMonad(x,a) CMonad(x,b) -- CMonad(x,c)
cmMap2(f) =
  pack2 MkCMonad(
    unpack2 dip(cmRun) swap
    result(
      nip err,
      dip(cmRun) swap
      result(
        nip err,
        f ok
      )
    )
  )

cmMap3(f: a b c -- d) : CMonad(x,a) CMonad(x,b) CMonad(x,c) -- CMonad(x,d)
cmMap3(f) = cmMap2(pack2) cmMap2(unpack2 f)

cmMap4(f: a b c d -- e) : CMonad(x,a) CMonad(x,b) CMonad(x,c) CMonad(x,d) -- CMonad(x,e)
cmMap4(f) = cmMap2(pack2) cmMap3(unpack2 f)

cmBind(f: a -- CMonad(x,b)) : CMonad(x,a) -- CMonad(x,b)
cmBind(f) =
  MkCMonad(
    cmRun
    result(
      err,
      f cmRun
    )
  )

cmBind2(f: a b -- CMonad(x,c)) : CMonad(x,a) CMonad(x,b) -- CMonad(x,c)
cmBind2(f) = cmMap2(pack2) cmBind(unpack2 f)

cmBind3(f: a b c -- CMonad(x,d)) : CMonad(x,a) CMonad(x,b) CMonad(x,c) -- CMonad(x,d)
cmBind3(f) = cmMap3(pack3) cmBind(unpack3 f)

cmBind4(f: a b c d -- CMonad(x,e)) : CMonad(x,a) CMonad(x,b) CMonad(x,c) CMonad(x,d) -- CMonad(x,e)
cmBind4(f) = cmMap4(pack4) cmBind(unpack4 f)

cmUnit : CMonad(x, Unit)
cmUnit = unit cmPure

cmVoid : CMonad(x,a) -- CMonad(x, Unit)
cmVoid = cmMap(drop unit)

cmVoid2 : CMonad(x,a) CMonad(x,b) -- CMonad(x, Unit)
cmVoid2 = cmMap2(drop2 unit)

cmSucc : CBind(x) CMonad(CSucc(x), t) -- CMonad(x, t)
cmSucc = pack2 MkCMonad(dip(tuck) unpack2 dip(CCS) cmRun dip(drop swap))

cmCtx : CMonad(x, CCtx(x))
cmCtx = unit MkCMonad(drop dup ok)

cmLookupVar : x -- CMonad(x, CBind(x))
cmLookupVar = dip(cmCtx) cmPure cmMap2(ccLookupVar)

cmLookupVarKind : x -- CMonad(x, CKind(x))
cmLookupVarKind = cmLookupVar cmMap(cbind->ckind)

cmEnv : CMonad(x, CEnv)
cmEnv = unit MkCMonad(drop over ok)

cmLookupSym : CSymbol -- CMonad(x, CDef)
cmLookupSym =
  dip(cmEnv) cmPure cmBind2(
    tuck ceLookupSym
    maybe(
      CEUndeclaredSymbol cmFail,
      nip cmPure
    )
  )

cmLookupSymKind : CSymbol -- CMonad(x, CKind(x))
cmLookupSymKind = cmLookupSym cmMap(cdef->ckind)

cmLookupSymMaybeTerm : CSymbol -- CMonad(x, Maybe(CTerm(x)))
cmLookupSymMaybeTerm = cmLookupSym cmMap(cdef->mcterm)

cbCheck : CBind(x) -- CMonad(x, Unit)
ckCheck : CKind(x) -- CMonad(x, Unit)
cstCheck : CStackType(x) -- CMonad(x, Unit)
cvtCheck : CValueType(x) -- CMonad(x, Unit)
ctCheck : CTerm(x) CKind(x) -- CMonad(x, Unit)
csCheck : CStack(x) CStackType(x) -- CMonad(x, Unit)
cvCheck : CValue(x) CValueType(x) -- CMonad(x, Unit)
cwCheck : CWord(x) CStackType(x) CStackType(x) -- CMonad(x, Unit)

ctInfer : CTerm(x) -- CMonad(x, CKind(x))
csInfer : CStack(x) -- CMonad(x, CStackType(x))
cvInfer : CValue(x) -- CMonad(x, CValueType(x))
cwInfer : CStackType(x) CWord(x) -- CMonad(x, CStackType(x))

caInfer : CKind(x) CArgs(x) -- CMonad(x, CKind(x))
caInferVar : x CArgs(x) -- CMonad(x, CKind(x))
caInferSym : CSymbol CArgs(x) -- CMonad(x, CKind(x))

cbCheckEq : CBind(x) CBind(x) -- CMonad(x, Unit)
ckCheckEq : CKind(x) CKind(x) -- CMonad(x, Unit)
cstCheckEq : CStackType(x) CStackType(x) -- CMonad(x, Unit)
cvtCheckEq : CValueType(x) CValueType(x) -- CMonad(x, Unit)
ctCheckEq : CTerm(x) CTerm(x) -- CMonad(x, Unit)
csCheckEq : CStack(x) CStack(x) -- CMonad(x, Unit)
cvCheckEq : CValue(x) CValue(x) -- CMonad(x, Unit)
cwCheckEq : CWord(x) CWord(x) -- CMonad(x, Unit)
caCheckEq : CArgs(x) CArgs(x) -- CMonad(x, Unit)
cmCheckVarEq : x x -- CMonad(x, Unit)
cmCheckSymEq : CSymbol CSymbol -- CMonad(x, Unit)

ckExpectLambda : CKind(x) -- CMonad(x, Pack(CBind(x) CKind(CSucc(x))))
ckExpectStackType : CKind(x) -- CMonad(x, Unit)
ckExpectValueType : CKind(x) -- CMonad(x, Unit)
ckExpectStack : CKind(x) -- CMonad(x, CStackType(x))
ckExpectValue : CKind(x) -- CMonad(x, CValueType(x))
ckExpectWord : CKind(x) -- CMonad(x, Pack(CStackType(x) CStackType(x)))

ctExpectLambda : CTerm(x) -- CMonad(x, Pack(CBind(x) CTerm(CSucc(x))))
ctExpectStackType : CTerm(x) -- CMonad(x, CStackType(x))
ctExpectValueType : CTerm(x) -- CMonad(x, CValueType(x))
ctExpectStack : CTerm(x) -- CMonad(x, CStack(x))
ctExpectValue : CTerm(x) -- CMonad(x, CValue(x))
ctExpectWord : CTerm(x) -- CMonad(x, Pack(CStackType(x) CWord(x)))

cstExpectVar : CStackType(x) -- CMonad(x, Pack(x CArgs(x)))
cstExpectNil : CStackType(x) -- CMonad(x, Unit)
cstExpectCons : CStackType(x) -- CMonad(x, Pack(CStackType(x) CValueType(x)))

cvtExpectVar : CValueType(x) -- CMonad(x, Pack(x CArgs(x)))
cvtExpectSym : CValueType(x) -- CMonad(x, Pack(CSymbol CArgs(x)))

csExpectVar : CStack(x) -- CMonad(x, Pack(x CArgs(x)))
csExpectNil : CStack(x) -- CMonad(x, Unit)
csExpectCons : CStack(x) -- CMonad(x, Pack(CStack(x) CValue(x)))
csExpectTail : CStack(x) -- CMonad(x, CStack(x))
csExpectRun : CStack(x) -- CMonad(x, Pack(CStack(x) CWord(x)))

cvExpectVar : CValue(x) -- CMonad(x, Pack(x CArgs(x)))
cvExpectSym : CValue(x) -- CMonad(x, Pack(CSymbol CArgs(x)))
cvExpectHead : CValue(x) -- CMonad(x, CStack(x))

cwExpectVar : CWord(x) -- CMonad(x, Pack(x CArgs(x)))
cwExpectSym : CWord(x) -- CMonad(x, Pack(CSymbol CArgs(x)))
cwExpectId : CWord(x) -- CMonad(x, Unit)
cwExpectCp : CWord(x) -- CMonad(x, Pack(CWord(x) CWord(x)))
cwExpectPush : CWord(x) -- CMonad(x, CValue(x))
cwExpectSwap : CWord(x) -- CMonad(x, Unit)
cwExpectDrop : CWord(x) -- CMonad(x, Unit)
cwExpectDup : CWord(x) -- CMonad(x, Unit)
cwExpectDip : CWord(x) -- CMonad(x, CWord(x))

caExpectNil : CArgs(x) -- CMonad(x, Unit)
caExpectConsL : CArgs(x) -- CMonad(x, Pack(CTerm(x) CArgs(x)))

ckNorm : CKind(x) -- CMonad(x, CKind(x))
ctNorm : CTerm(x) -- CMonad(x, CTerm(x))
cstNorm : CStackType(x) -- CMonad(x, CStackType(x))
cvtNorm : CValueType(x) -- CMonad(x, CValueType(x))
csNorm : CStack(x) -- CMonad(x, CStack(x))
cvNorm : CValue(x) -- CMonad(x, CValue(x))
cwNorm : CWord(x) -- CMonad(x, CWord(x))
caNorm : CArgs(x) -- CMonad(x, CArgs(x))

cbCheck = cbind->ckind ckCheck

ckCheck =
  match(
    CKLambda -> dip(dup dip(cbCheck)) ckCheck cmSucc cmVoid2,
    CKStackType -> cmUnit,
    CKValueType -> cmUnit,
    CKStack -> cstCheck,
    CKValue -> cvtCheck,
    CKWord -> dip(cstCheck) cstCheck cmVoid2
  )

cstCheck =
  match(
    CSTVar -> caInferVar cmBind(ckExpectStackType),
    CSTNil -> cmUnit,
    CSTCons -> dip(cstCheck) cvtCheck cmVoid2
  )

cvtCheck =
  match(
    CVTVar -> caInferVar cmBind(ckExpectValueType),
    CVTSym -> caInferSym cmBind(ckExpectValueType)
  )

ctCheck = dip(ctInfer) cmPure cmBind2(ckCheckEq)
csCheck = dip(csInfer) cmPure cmBind2(cstCheckEq)
cvCheck = dip(cvInfer) cmPure cmBind2(cvtCheckEq)
cwCheck = dip(swap cwInfer) cmPure cmBind2(cstCheckEq)

ctInfer =
  match(
    CTLambda ->
      dip(dup dip(cbind->ckind ckCheck))
      dip(dup dip(cmPure))
      ctInfer cmSucc
      cmMap3(CKLambda nip),
    CTStackType -> cstCheck cmMap(drop CKStackType),
    CTValueType -> cvtCheck cmMap(drop CKValueType),
    CTStack -> csInfer cmMap(CKStack),
    CTValue -> cvInfer cmMap(CKValue),
    CTWord ->
      dip(dup dip(cstCheck))
      dip(dup dip(cmPure))
      cwInfer cmMap3(CKWord nip)
  )

csInfer =
  match(
    CSVar -> caInferVar cmBind(ckExpectStack),
    CSNil -> CSTNil cmPure,
    CSCons -> dip(csInfer) cvInfer cmMap2(CSTCons),
    CSTail -> csInfer cmBind(cstExpectCons cmMap(unpack2 drop)),
    CSRun -> dip(csInfer) cmPure cmBind2(cwInfer)
  )

cvInfer =
  match(
    CVVar -> caInferVar cmBind(ckExpectValue),
    CVSym -> caInferSym cmBind(ckExpectValue),
    CVHead -> csInfer cmBind(cstExpectCons cmMap(unpack2 nip))
  )

cwInfer =
  match(
    CWVar ->
      dip2(cmPure) caInferVar cmBind(ckExpectWord)
      cmBind2(unpack2 dip(cstCheckEq) cmPure cmMap2(nip)),
    CWSym ->
      dip2(cmPure) caInferSym cmBind(ckExpectWord)
      cmBind2(unpack2 dip(cstCheckEq) cmPure cmMap2(nip)),
    CWId ->
      cmPure,
    CWCp ->
      dip(cwInfer) cmPure cmBind2(cwInfer),
    CWPush ->
      dip(cmPure) cvInfer cmMap2(CSTCons),
    CWSwap ->
      cstExpectCons cmBind(
        unpack2 dip(cstExpectCons) cmPure cmMap2(
          dip(unpack2) swap dip(CSTCons) CSTCons
        )
      ),
    CWDrop ->
      cstExpectCons cmMap(unpack2 drop),
    CWDup ->
      cstExpectCons cmMap(unpack2 dup dip(CSTCons) CSTCons),
    CWDip ->
      dip(cstExpectCons) cmPure cmBind2(
        dip(unpack2) swap dip(cwInfer) cmPure
        cmMap2(CSTCons)
      )
  )

caInfer =
  caMatchL(
    cmPure,
    dip2(ckExpectLambda) cmPure2 cmBind3(
      dip2(unpack2) dip(swap)
      dip2(tuck dip(cbind->ckind ctCheck))
      pack3 cmPure cmBind2(
        nip unpack3
        dip(ckSubst(csucc(dup Right, Left)) nip)
        caInfer
      )
    )
  )

caInferVar = dip(cmLookupVarKind) cmPure cmBind2(caInfer)
caInferSym = dip(cmLookupSymKind) cmPure cmBind2(caInfer)

mkEqCheck0 (
  d: t -- CMonad(x, Unit)
) : t -- CMonad(x, Unit)

mkEqCheck1 (
  d: t -- CMonad(x, a),
  f: a a -- CMonad(x, Unit)
) : t a -- CMonad(x, Unit)

mkEqCheck2 (
  d: t -- CMonad(x, Pack(a b)),
  f: a a -- CMonad(x, Unit),
  g: b b -- CMonad(x, Unit)
) : t a b -- CMonad(x, Unit)

mkEqCheckSucc (
  d: t -- CMonad(x, Pack(CBind(x) b)),
  g: b b -- CMonad(CSucc(x), Unit)
) : t CBind(x) b -- CMonad(x, Unit)

mkEqCheck0(d) = d
mkEqCheck1(d,f) = dip(d) cmPure cmBind2(f)
mkEqCheck2(d,f,g) =
  dip2(d) cmPure2 cmBind3(
    dip2(unpack2) dip(swap)
    dip2(f) g cmVoid2
  )
mkEqCheckSucc(d,g) =
  dip2(d) cmPure2 cmBind3(
    dip2(unpack2) dip(swap)
    dip2(dup dip(cbCheckEq)) g cmSucc cmVoid2
  )

ckCheckEq =
  dip(cmPure) ckNorm cmBind2(
    match(
      CKLambda -> mkEqCheckSucc(ckExpectLambda, ckCheckEq),
      CKStackType -> mkEqCheck0(ckExpectStackType),
      CKValueType -> mkEqCheck0(ckExpectValueType),
      CKStack -> mkEqCheck1(ckExpectStack, cstCheckEq),
      CKValue -> mkEqCheck1(ckExpectValue, cvtCheckEq),
      CKWord -> mkEqCheck2(ckExpectWord, cstCheckEq, cstCheckEq)
    )
  )

cstCheckEq =
  dip(cmPure) cstNorm cmBind2(
    match(
      CSTVar -> mkEqCheck2(cstExpectVar, cmCheckVarEq, caCheckEq),
      CSTNil -> mkEqCheck0(cstExpectNil),
      CSTCons -> mkEqCheck2(cstExpectCons, cstCheckEq, cvtCheckEq)
    )
  )

cvtCheckEq =
  dip(cmPure) cvtNorm cmBind2(
    match(
      CVTVar -> mkEqCheck2(cvtExpectVar, cmCheckVarEq, caCheckEq),
      CVTSym -> mkEqCheck2(cvtExpectSym, cmCheckSymEq, caCheckEq)
    )
  )

ctCheckEq =
  dip(cmPure) ctNorm cmBind2(
    match(
      CTLambda -> mkEqCheckSucc(ctExpectLambda, ctCheckEq),
      CTStackType -> mkEqCheck1(ctExpectStackType, cstCheckEq),
      CTValueType -> mkEqCheck1(ctExpectValueType, cvtCheckEq),
      CTStack -> mkEqCheck1(ctExpectStack, csCheckEq),
      CTValue -> mkEqCheck1(ctExpectValue, cvCheckEq),
      CTWord -> mkEqCheck2(ctExpectWord, cstCheckEq, cwCheckEq)
    )
  )

csCheckEq =
  dip(cmPure) csNorm cmBind2(
    match(
      CSVar -> mkEqCheck2(csExpectVar, cmCheckVarEq, caCheckEq),
      CSNil -> mkEqCheck0(csExpectNil),
      CSCons -> mkEqCheck2(csExpectCons, csCheckEq, cvCheckEq),
      CSTail -> mkEqCheck1(csExpectTail, csCheckEq),
      CSRun -> mkEqCheck2(csExpectRun, csCheckEq, cwCheckEq)
    )
  )

cwCheckEq =
  dip(cmPure) cwNorm cmBind2(
    match(
      CWVar -> mkEqCheck2(cwExpectVar, cmCheckVarEq, caCheckEq),
      CWSym -> mkEqCheck2(cwExpectSym, cmCheckSymEq, caCheckEq),
      CWId -> mkEqCheck0(cwExpectId),
      CWCp -> mkEqCheck2(cwExpectCp, cwCheckEq, cwCheckEq),
      CWPush -> mkEqCheck1(cwExpectPush, cvCheckEq),
      CWSwap -> mkEqCheck0(cwExpectSwap),
      CWDrop -> mkEqCheck0(cwExpectDrop),
      CWDup -> mkEqCheck0(cwExpectDup),
      CWDip -> mkEqCheck1(cwExpectDip, cwCheckEq)
    )
  )

caCheckEq =
  dip(cmPure) caNorm cmBind2(
    caMatchL(
      mkEqCheck0(caExpectNil),
      mkEqCheck2(caExpectConsL, ctCheckEq, caCheckEq)
    )
  )

ckExpectLambda = ckNorm cmBind(match(CKLambda -> pack2 cmPure, _ -> drop "CKLambda" CEExpectedForm cmFail))
ckExpectStackType = ckNorm cmBind(match(CKStackType -> cmUnit, _ -> drop "CKStackType" CEExpectedForm cmFail))
ckExpectValueType = ckNorm cmBind(match(CKValueType -> cmUnit, _ -> drop "CKValueType" CEExpectedForm cmFail))
ckExpectStack = ckNorm cmBind(match(CKStack -> cmPure, _ -> drop "CKStack" CEExpectedForm cmFail))
ckExpectValue = ckNorm cmBind(match(CKValue -> cmPure, _ -> drop "CKValue" CEExpectedForm cmFail))
ckExpectWord = ckNorm cmBind(match(CKWord -> pack2 cmPure, _ -> drop "CKWord" CEExpectedForm cmFail))

ctExpectLambda = ctNorm cmBind(match(CTLambda -> pack2 cmPure, _ -> drop "CTLambda" CEExpectedForm cmFail))
ctExpectStackType = ctNorm cmBind(match(CTStackType -> cmPure, _ -> drop "CTStackType" CEExpectedForm cmFail))
ctExpectValueType = ctNorm cmBind(match(CTValueType -> cmPure, _ -> drop "CTValueType" CEExpectedForm cmFail))
ctExpectStack = ctNorm cmBind(match(CTStack -> cmPure, _ -> drop "CTStack" CEExpectedForm cmFail))
ctExpectValue = ctNorm cmBind(match(CTValue -> cmPure, _ -> drop "CTValue" CEExpectedForm cmFail))
ctExpectWord = ctNorm cmBind(match(CTWord -> pack2 cmPure, _ -> drop "CTWord" CEExpectedForm cmFail))

cstExpectVar = cstNorm cmBind(match(CSTVar -> pack2 cmPure, _ -> drop "CSTVar" CEExpectedForm cmFail))
cstExpectNil = cstNorm cmBind(match(CSTNil -> cmUnit, _ -> drop "CSTNil" CEExpectedForm cmFail))
cstExpectCons = cstNorm cmBind(match(CSTCons -> pack2 cmPure, _ -> drop "CSTCons" CEExpectedForm cmFail))

cvtExpectVar = cvtNorm cmBind(match(CVTVar -> pack2 cmPure, _ -> drop "CVTVar" CEExpectedForm cmFail))
cvtExpectSym = cvtNorm cmBind(match(CVTSym -> pack2 cmPure, _ -> drop "CVTSym" CEExpectedForm cmFail))

csExpectVar = csNorm cmBind(match(CSVar -> pack2 cmPure, _ -> drop "CSVar" CEExpectedForm cmFail))
csExpectNil = csNorm cmBind(match(CSNil -> cmUnit, _ -> drop "CSNil" CEExpectedForm cmFail))
csExpectCons = csNorm cmBind(match(CSCons -> pack2 cmPure, _ -> drop "CSCons" CEExpectedForm cmFail))
csExpectTail = csNorm cmBind(match(CSTail -> cmPure, _ -> drop "CSTail" CEExpectedForm cmFail))
csExpectRun = csNorm cmBind(match(CSRun -> pack2 cmPure, _ -> drop "CSRun" CEExpectedForm cmFail))

cvExpectVar = cvNorm cmBind(match(CVVar -> pack2 cmPure, _ -> drop "CVVar" CEExpectedForm cmFail))
cvExpectSym = cvNorm cmBind(match(CVSym -> pack2 cmPure, _ -> drop "CVSym" CEExpectedForm cmFail))
cvExpectHead = cvNorm cmBind(match(CVHead -> cmPure, _ -> drop "CVHead" CEExpectedForm cmFail))

cwExpectVar = cwNorm cmBind(match(CWVar -> pack2 cmPure, _ -> drop "CWVar" CEExpectedForm cmFail))
cwExpectSym = cwNorm cmBind(match(CWSym -> pack2 cmPure, _ -> drop "CWSym" CEExpectedForm cmFail))
cwExpectId = cwNorm cmBind(match(CWId -> cmUnit, _ -> drop "CWId" CEExpectedForm cmFail))
cwExpectCp = cwNorm cmBind(match(CWCp -> pack2 cmPure, _ -> drop "CWCp" CEExpectedForm cmFail))
cwExpectPush = cwNorm cmBind(match(CWPush -> cmPure, _ -> drop "CWPush" CEExpectedForm cmFail))
cwExpectSwap = cwNorm cmBind(match(CWSwap -> cmUnit, _ -> drop "CWSwap" CEExpectedForm cmFail))
cwExpectDrop = cwNorm cmBind(match(CWDrop -> cmUnit, _ -> drop "CWDrop" CEExpectedForm cmFail))
cwExpectDup = cwNorm cmBind(match(CWDup -> cmUnit, _ -> drop "CWDup" CEExpectedForm cmFail))
cwExpectDip = cwNorm cmBind(match(CWDip -> cmPure, _ -> drop "CWDip" CEExpectedForm cmFail))

caExpectNil = caNorm cmBind(caMatchL(cmUnit, drop2 "CANil" CEExpectedForm cmFail))
caExpectConsL = caNorm cmBind(caMatchL("CAConsL" CEExpectedForm cmFail, pack2 cmPure))

cwStep : CStack(x) CWord(x) -- CMonad(x, Either(CStack(x), Pack(CStack(x) CWord(x))))
cwSteps : CStack(x) CWord(x) -- CMonad(x, CStack(x))

cmExpandSym(
  f: CSymbol CArgs(x) -- t,
  g: CTerm(x) -- CMonad(x, t),
  n: t -- CMonad(x, t)
) : CSymbol CArgs(x) -- CMonad(x, t)

cmExpandSym(f,g,n) =
  over dip(cmPure2) cmLookupSymMaybeTerm cmBind3(
    maybe(
      f cmPure,
      swap ctApply nip g cmBind(n)
    )
  )

ckNorm = cmPure
ctNorm = cmPure
caNorm = cmPure

################################
# Normalization By Evaluation
#
# We map each syntactic sort (e.g. CStack(x)) into either
# (CEStack(x)) a  canonical (CCStack(x)) or neutral
# (CNStack(x)) version. The exception is CWord(x) is broken
# into a list (CEWord(x)) of word atoms (CEWord1(x)) which
# are themselves either neutral or canonical.
################################

type CEStackType(x)
type CEValueType(x)
type CEStack(x)
type CEValue(x)
type CEWord(x)
type CEWord1(x)

type CNStackType(x)
type CNValueType(x)
type CNStack(x)
type CNValue(x)
type CNWord1(x)

type CCStackType(x)
type CCValueType(x)
type CCStack(x)
type CCValue(x)
type CCWord1(x)

data CEStackType(x)
  CESTN : CNStackType(x) -- CEStackType(x)
  CESTC : CCStackType(x) -- CEStackType(x)
end

data CNStackType(x)
  CNSTVar : x CArgs(x) -- CNStackType(x)
end

data CCStackType(x)
  CCSTNil : CCStackType(x)
  CCSTCons : CStackType(x) CValueType(x) -- CCStackType(x)
end

data CEValueType(x)
  CEVTN : CNValueType(x) -- CEValueType(x)
  CEVTC : CCValueType(x) -- CEValueType(x)
end

data CNValueType(x)
  CNVTVar : x CArgs(x) -- CNValueType(x)
  CNVTSym : CSymbol CArgs(x) -- CNValueType(x)
end

data CCValueType(x)
end

data CEStack(x)
  CESN : CNStack(x) -- CEStack(x)
  CESC : CCStack(x) -- CEStack(x) 
end

data CNStack(x)
  CNSVar : x CArgs(x) -- CNStack(x)
  CNSTail : CNStack(x) -- CNStack(x)
  CNSRun : CStack(x) CEWord1(x) -- CNStack(x)
end

data CCStack(x)
  CCSNil : CCStack(x)
  CCSCons : CStack(x) CValue(x) -- CCStack(x)
end

data CEValue(x)
  CEVN : CNValue(x) -- CEValue(x)
  CEVC : CCValue(x) -- CEValue(x)
end

data CNValue(x)
  CNVVar : x CArgs(x) -- CNValue(x)
  CNVSym : CSymbol CArgs(x) -- CNValue(x)
  CNVHead : CNStack(x) -- CNValue(x)
end

data CCValue(x)
end

data CEWord(x)
  MkCEWord : List(CEWord1(x)) -- CEWord(x)
end

unCEWord : CEWord(x) -- List(CEWord1(x))
unCEWord = match(MkCEWord -> id)

data CEWord1(x)
  CEWN : CNWord1(x) -- CEWord1(x)
  CEWC : CCWord1(x) -- CEWord1(x)
end

data CNWord1(x)
  CNWVar : x CArgs(x) -- CNWord1(x)
  CNWSym : CSymbol CArgs(x) -- CNWord1(x)
end

data CCWord1(x)
  CCWPush : CValue(x) -- CCWord1(x)
  CCWSwap : CCWord1(x)
  CCWDrop : CCWord1(x)
  CCWDup : CCWord1(x)
  CCWDip : CWord(x) -- CCWord1(x)
end

cewId : CEWord(x)
cewCp : CEWord(x) CEWord(x) -- CEWord(x)
cew1 : CEWord1(x) -- CEWord(x)

cewId = nil MkCEWord
cewCp = dip(unCEWord) unCEWord ++ MkCEWord
cew1 = lpure MkCEWord

cestQuote : CEStackType(x) -- CStackType(x)
cnstQuote : CNStackType(x) -- CStackType(x)
ccstQuote : CCStackType(x) -- CStackType(x)

cevtQuote : CEValueType(x) -- CValueType(x)
cnvtQuote : CNValueType(x) -- CValueType(x)
ccvtQuote : CCValueType(x) -- CValueType(x)

cesQuote : CEStack(x) -- CStack(x)
cnsQuote : CNStack(x) -- CStack(x)
ccsQuote : CCStack(x) -- CStack(x)

cevQuote : CEValue(x) -- CValue(x)
cnvQuote : CNValue(x) -- CValue(x)
ccvQuote : CCValue(x) -- CValue(x)

cewQuote : CEWord(x) -- CWord(x)
cew1Quote : CEWord1(x) -- CWord(x)
cnw1Quote : CNWord1(x) -- CWord(x)
ccw1Quote : CCWord1(x) -- CWord(x)

cstEval : CStackType(x) -- CMonad(x, CEStackType(x))
cvtEval : CValueType(x) -- CMonad(x, CEValueType(x))
csEval : CStack(x) -- CMonad(x, CEStack(x))
cvEval : CValue(x) -- CMonad(x, CEValue(x))
cwEval : CWord(x) -- CMonad(x, CEWord(x))

cstNorm : CStackType(x) -- CMonad(x, CStackType(x))
cvtNorm : CValueType(x) -- CMonad(x, CValueType(x))
csNorm : CStack(x) -- CMonad(x, CStack(x))
cvNorm : CValue(x) -- CMonad(x, CValue(x))
cwNorm : CWord(x) -- CMonad(x, CWord(x))

cstNorm = cstEval cmMap(cestQuote)
cvtNorm = cvtEval cmMap(cevtQuote)
csNorm = csEval cmMap(cesQuote)
cvNorm = cvEval cmMap(cevQuote)
cwNorm = cwEval cmMap(cewQuote)

cestQuote = match(CESTN -> cnstQuote, CESTC -> ccstQuote)
cnstQuote =
  match(
    CNSTVar -> CSTVar
  )
ccstQuote =
  match(
    CCSTNil -> CSTNil,
    CCSTCons -> CSTCons
  )

cevtQuote = match(CEVTN -> cnvtQuote, CEVTC -> ccvtQuote)
cnvtQuote =
  match(
    CNVTVar -> CVTVar,
    CNVTSym -> CVTSym
  )
ccvtQuote =
  match

cesQuote = match(CESN -> cnsQuote, CESC -> ccsQuote)
cnsQuote = 
  match(
    CNSVar -> CSVar,
    CNSTail -> cnsQuote CSTail,
    CNSRun -> cew1Quote CSRun
  )

ccsQuote =
  match(
    CCSNil -> CSNil,
    CCSCons -> CSCons
  )

cevQuote = match(CEVN -> cnvQuote, CEVC -> ccvQuote)
cnvQuote =
  match(
    CNVVar -> CVVar,
    CNVSym -> CVSym,
    CNVHead -> cnsQuote CVHead
  )

ccvQuote =
  match

cewQuote = 
  match(
    MkCEWord ->
      lmatchL(CWId, dip(cew1Quote) for(cew1Quote CWCp))
  )

cew1Quote = match(CEWN -> cnw1Quote, CEWC -> ccw1Quote)

cnw1Quote =
  match(
    CNWVar -> CWVar,
    CNWSym -> CWSym
  )

ccw1Quote =
  match(
    CCWPush -> CWPush,
    CCWSwap -> CWSwap,
    CCWDrop -> CWDrop,
    CCWDup -> CWDup,
    CCWDip -> CWDip
  )


cstEval =
  match(
    CSTVar -> CNSTVar CESTN cmPure,
    CSTNil -> CCSTNil CESTC cmPure,
    CSTCons -> CCSTCons CESTC cmPure
  )

cvtEval =
  match(
    CVTVar -> CNVTVar CEVTN cmPure,
    CVTSym -> CNVTSym CEVTN cmPure # TODO: expand the symbol
  )

csEvalRun : CStack(x) CWord(x) -- CMonad(x, CEStack(x))
csEvalRun1 : CStack(x) CEWord1(x) -- CMonad(x, CEStack(x))
csEvalSwap : CStack(x) -- CMonad(x, CEStack(x))
csEvalDup : CStack(x) -- CMonad(x, CEStack(x))
csEvalDip : CStack(x) CWord(x) -- CMonad(x, CEStack(x))

csEval =
  match(
    CSVar -> CNSVar CESN cmPure,
    CSNil -> CCSNil CESC cmPure,
    CSCons -> CCSCons CESC cmPure,
    CSTail ->
      csEval cmBind(match(
        CESN -> CNSTail CESN cmPure,
        CESC -> match(
          CCSNil -> "attempted to get tail of empty stack" CERuntimeTypeError cmFail,
          CCSCons -> drop csEval
        )
      )),
    CSRun -> csEvalRun
  )

csEvalRun =
  dip(cmPure) cwEval cmBind2(
    unCEWord lmatchR(
      csEval,
      dip(MkCEWord cewQuote CSRun) csEvalRun1  
    )
  )

csEvalRun1 =
  match(
    CEWN -> CEWN CNSRun CESN cmPure,
    CEWC ->
      match(
        CCWPush -> CCSCons CESC cmPure,
        CCWSwap -> csEvalSwap,
        CCWDrop -> CSTail csEval,
        CCWDup -> csEvalDup,
        CCWDip -> csEvalDip
      )
  )

csEvalDup =
  csEval cmBind(
    match(
      CESN -> cnsQuote CCWDup CEWC CNSRun CESN cmPure,
      CESC -> 
        match(
          CCSNil -> "attempted to run dup on empty stack" CERuntimeTypeError cmFail,
          CCSCons -> dup dip(CSCons) CCSCons CESC cmPure
        )
    )
  )

csEvalDip =
  dip(csEval) cmPure cmBind2(
    swap match(
      CESN -> cnsQuote swap CCWDip CEWC CNSRun CESN cmPure,
      CESC ->
        match(
          CCSNil -> drop "attempted to run dip on empty stack" CERuntimeTypeError cmFail,
          CCSCons -> dip(swap CSRun) CCSCons CESC cmPure 
        )
    )
  )

csEvalSwap =
  csEval cmBind(
    match(
      CESN -> cnsQuote CCWSwap CEWC CNSRun CESN cmPure,
      CESC ->
        match(
          CCSNil -> "attempted to run swap on empty stack" CERuntimeTypeError cmFail,
          CCSCons -> CWPush csEvalDip
        )
    )
  )


cvEval =
  match(
    CVVar -> CNVVar CEVN cmPure,
    CVSym -> CNVSym CEVN cmPure, # TODO: expand the symbol
    CVHead ->
      csEval cmBind(match(
        CESN -> CNVHead CEVN cmPure,
        CESC -> match(
          CCSNil -> "attempted to get head of empty stack" CERuntimeTypeError cmFail,
          CCSCons -> nip cvEval
        )
      ))
  )

cwEval =
  match(
    CWId -> cewId cmPure,
    CWCp -> dip(cwEval) cwEval cmMap2(cewCp),
    CWVar -> CNWVar CEWN cew1 cmPure,
    CWSym -> CNWSym CEWN cew1 cmPure, # TODO: expand the symbol
    CWPush -> CCWPush CEWC cew1 cmPure,
    CWSwap -> CCWSwap CEWC cew1 cmPure,
    CWDrop -> CCWDrop CEWC cew1 cmPure,
    CWDup -> CCWDup CEWC cew1 cmPure,
    CWDip -> CCWDip CEWC cew1 cmPure
  )



