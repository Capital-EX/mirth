
import base/unit
import base/maybe
import base/result
import base/list
import base/str
import base/int
import base/nat
import base/sexp
import base/map
import base/set

import mirth/loc
import mirth/pkg
import mirth/mod
import mirth/syntax

export mirth/elab
  type Result(a,b)
  type EEnv
  type EError
  type EMonad(t)

  type ESym
  type ETerm
  type EEffect
  type EStack
  type EType
  type EKind
  type EBind
  type ECtx

  emRun : EEnv EMonad(t) -- EEnv Result(EError,t)
  emFail : Str -- EMonad(a)
  emPure : a -- EMonad(a)
  emPure2 : a b -- EMonad(a) EMonad(b)
  emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
  emMap(f: a -- b) : EMonad(a) -- EMonad(b)
  emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
  emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
  emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
  emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
  emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)

  type EModule

  runElabModule : Mod L(Module) -- Result(EError, EModule)
  eerror->str : EError -- Str
  emodule->str : EModule -- Str

end

||| Elaborator error.
data EError
  MkEError : Str -- EError
end

unEError : EError -- Str
unEError = match(MkEError -> id)

eerror->str : EError -- Str
eerror->str = unEError

||| Elaboration monad.
data EMonad(t)
  MkEMonad(f: EEnv m -- EEnv Result(EError, t)) : m -- EMonad(t)
end

emUse(f: EEnv a -- EEnv b) : a -- EMonad(b)
emUse(f) = MkEMonad(f ok)

emGet(f: EEnv -- EEnv b) : EMonad(b)
emGet(f) = unit emUse(drop f)

emPut(f: EEnv t -- EEnv) : t -- EMonad(Unit)
emPut(f) = emUse(f unit)

emRun : EEnv EMonad(t) -- EEnv Result(EError, t)
emRun = match(MkEMonad(f) -> f)

emPure : a -- EMonad(a)
emPure = MkEMonad(ok)

emFail : Str -- EMonad(a)
emFail = MkEMonad(MkEError err)

emPure2 : a b -- EMonad(a) EMonad(b)
emPure2 = dip(emPure) emPure

emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
emPure3 = dip(emPure2) emPure

emMap(f: a -- b) : EMonad(a) -- EMonad(b)
emMap(f) = MkEMonad(emRun rmap(f))

emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
emMap2(f) =
  pack2 MkEMonad(
    unpack2 dip(emRun) swap
    result(nip err,
      dip(emRun) swap
      result(nip err, f ok)
    )
  )

emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emMap3(f) = emMap2(pack2) emMap2(unpack2 f)

emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emMap4(f) = emMap2(pack2) emMap3(unpack2 f)

emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
emBind(f) = MkEMonad(emRun result(err, f emRun))

emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
emBind2(f) = emMap2(pack2) emBind(unpack2 f)

emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emBind3(f) = emMap3(pack3) emBind(unpack3 f)

emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emBind4(f) = emMap4(pack4) emBind(unpack4 f)

emUnit : EMonad(Unit)
emUnit = unit emPure

emVoid : EMonad(a) -- EMonad(Unit)
emVoid = emMap(drop unit)

emVoid2 : EMonad(a) EMonad(b) -- EMonad(Unit)
emVoid2 = emMap2(drop2 unit)

###############
# Elaboration #
###############


||| A type definition.
data EDefType
  MkEDefType : EDefType
end

unEDefType : EDefType --
unEDefType = match(MkEDefType -> id)

edeftype->sexp : EDefType -- Sexp
edeftype->sexp = unEDefType "type" sexpAtom


||| A word definition.
data EDefWord
  MkEDefWord : EDefWord
end

unEDefWord : EDefWord --
unEDefWord = match(MkEDefWord -> id)

edefword->sexp : EDefWord -- Sexp
edefword->sexp = unEDefWord "word" sexpAtom


||| A definition.
data EDef
  EDType : EDefType -- EDef
  EDWord : EDefWord -- EDef
end

edef->sexp : EDef -- Sexp
edef->sexp =
  match(
    EDType -> edeftype->sexp,
    EDWord -> edefword->sexp
  )


||| A set of definitions in a single scope.
data EDefs
  MkEDefs : Map(Name, EDef) -- EDefs
end

unEDefs : EDefs -- Map(Name, EDef)
unEDefs = match(MkEDefs -> id)

edefsNil : EDefs
edefsNil = mapNil MkEDefs

edefsGet : EDefs Name -- Maybe(EDef)
edefsGet = dip(unEDefs) mapGet

edefsSet : EDefs Name EDef -- EDefs
edefsSet = dip2(unEDefs) mapSet MkEDefs

edefs->sexp : EDefs -- Sexp
edefs->sexp = unEDefs map->sexp(name->sexp, edef->sexp)


||| A single interface.
data EInterface
  MkEInterface : Pkg Interface EDefs -- EInterface
end

unEInterface : EInterface -- Pkg Interface EDefs
unEInterface = match(MkEInterface -> id)

einterface->sexp : EInterface -- Sexp
einterface->sexp = $(
  unEInterface
  dip3("interface" sexpAtom lpure)
  dip2(pkg->sexp cons)
  dip(interface->sexp cons)
  edefs->sexp cons
  sexpList
)


||| A module's imports, i.e. a set of interfaces.
data EImports
  MkEImports : Set(Interface) -- EImports
end

unEImports : EImports -- Set(Interface)
unEImports = match(MkEImports -> id)

eimportsNil : EImports
eimportsNil = setNil MkEImports

eimports->sexp : EImports -- Sexp
eimports->sexp = unEImports set->sexp(interface->sexp)


||| A module's exports, i.e. a map of interface definitions.
data EExports
  MkEExports : Map(Interface, EInterface) -- EExports
end

unEExports : EExports -- Map(Interface, EInterface)
unEExports = match(MkEExports -> id)

eexportsNil : EExports
eexportsNil = mapNil MkEExports

eexports->sexp : EExports -- Sexp
eexports->sexp = unEExports map->sexp(interface->sexp, einterface->sexp)


||| A single Mirth module.
data EModule
  MkEModule : Mod EImports EExports EDefs -- EModule
end

unEModule : EModule -- Mod EImports EExports EDefs
unEModule = match(MkEModule -> id)

emoduleNil : Mod -- EModule
emoduleNil = eimportsNil eexportsNil edefsNil MkEModule

emodule->sexp : EModule -- Sexp
emodule->sexp = $(
  unEModule
  dip4("module" sexpAtom lpure)
  dip3(mod->sexp cons)
  dip2(eimports->sexp cons)
  dip(eexports->sexp cons)
  edefs->sexp cons
  sexpList
)

emodule->str : EModule -- Str
emodule->str = emodule->sexp sexp->str


||| A Mirth package, i.e. a collection of modules and interfaces.
data EPackage
  MkEPackage : Pkg EExports Map(Mod, EModule) -- EPackage
end

unEPackage : EPackage -- Pkg EExports Map(Mod, EModule)
unEPackage = match(MkEPackage -> id)

epackageNil : Pkg -- EPackage
epackageNil = eexportsNil mapNil MkEPackage

epackage->sexp : EPackage -- Sexp
epackage->sexp = $(
  unEPackage
  dip3("package" sexpAtom lpure)
  dip2(pkg->sexp cons)
  dip(eexports->sexp cons)
  map->sexp(mod->sexp, emodule->sexp) cons
  sexpList
)


||| Elaboration World -- The collection of loaded packages and modules.
||| This should be unchanged during module elaboration.
data EWorld
  MkEWorld : Map(Pkg, EPackage) -- EWorld
end

unEWorld : EWorld -- Map(Pkg, EPackage)
unEWorld = match(MkEWorld -> id)

eworldNil : EWorld
eworldNil = mapNil MkEWorld


||| Elaboration Focus -- The current package/module/interface being
||| elaborated. This should be unchanged during expression elaboration.
data EFocus
  EFNone : EFocus
  EFPackage : EPackage -- EFocus
  EFModule : EPackage EModule -- EFocus
  EFInterface : EPackage EModule EInterface -- EFocus
end

efocusNil : EFocus
efocusNil = EFNone

||| Create an empty package focus for a Pkg.
efocusNilPkg : Pkg -- EFocus
efocusNilPkg = epackageNil EFPackage

||| Create an empty module focus for a Mod, for testing purposes.
efocusNilMod : Mod -- EFocus
efocusNilMod = dup dip(mod->pkg epackageNil) emoduleNil EFModule

data ESym
  MkESym : Pkg Mod Name -- ESym
end

data EEffect
  EEVar : Name -- EEffect
  EESym : ESym -- EEffect
  EENil : EEffect
end

data EStack
  ESVar : Name -- EStack
  ESNil : EStack
  ESCons : EStack EType -- EStack
end

data EType
  ETVar : Name -- EType
  ETSym : ESym List(EType) -- EType
end

data EWord
  EWId : EWord
  EWCp : EWord EWord -- EWord
  EWSwap : EWord
  EWDrop : EWord
  EWDup : EWord
  EWDip : EWord -- EWord
end

||| Additional info associated with a binding.
data EMeta(t)
  ||| Binding represents a rigid variable, i.e. we can't instantiate
  ||| during unification. The Bool controls whether the variable
  ||| was passed implicitly or explicitly.
  EMRigid : Bool -- EMeta(t)

  ||| Binding represents a plastic variable, i.e. we can instantiate
  ||| it once during unification. The Maybe(t) represents the value
  ||| it was instantiated to, if it was, and Set(Name) represents
  ||| the set of rigid free variables that are allowed in the
  ||| instantiated value
  EMPlastic : Set(Name) Maybe(t) -- EMeta(t)
end

emetaIsRigid : EMeta(t) -- Bool
emetaIsRigid =
  match(
    EMRigid -> drop true,
    EMPlastic -> drop2 false
  )

data EBind
  EBStack : EMeta(EStack) -- EBind
  EBType : EMeta(EType) -- EBind
  EBEffect : EMeta(EEffect) -- EBind
  EBWord : EStack EStack EEffect EMeta(EWord) -- EBind
end

ebindIsRigid : EBind -- Bool
ebindIsRigid =
  match(
    EBStack -> emetaIsRigid,
    EBType -> emetaIsRigid,
    EBEffect -> emetaIsRigid,
    EBWord -> dip(drop3) emetaIsRigid
  )

ebindIsPlastic : EBind -- Bool
ebindIsPlastic = ebindIsRigid not


data EBinds
  MkEBinds : Map(Name, EBind) -- EBinds
end

unEBinds : EBinds -- Map(Name, EBind)
unEBinds = match(MkEBinds -> id)

ebindsNil : EBinds
ebindsNil = mapNil MkEBinds

ebindsGet : EBinds Name -- Maybe(EBind)
ebindsGet = dip(unEBinds) mapGet

ebindsSet : EBinds Name EBind -- EBinds
ebindsSet = dip2(unEBinds) mapSet MkEBinds


||| Local Scope
data ECtx
  MkECtx : EBinds Maybe(EStack) -- ECtx
end

unECtx : ECtx -- EBinds Maybe(EStack)
unECtx = match(MkECtx -> id)

ectxNil : ECtx
ectxNil = ebindsNil none MkECtx

ectxUseBinds(f: EBinds a -- EBinds b) : ECtx a -- ECtx b
ectxUseBinds(f) = dip(unECtx) dip'(f) dip(MkECtx)

ectxUseStack(f: Maybe(EStack) a -- Maybe(EStack) b) : ECtx a -- ECtx b
ectxUseStack(f) = dip(unECtx) f dip(MkECtx)

ectxVars : ECtx -- Set(Name)
ectxVars = unECtx drop unEBinds mapKeys

||| Environment -- The current scope and metavariables.
data ELocal
  MkELocal : ECtx LocSet Nat -- ELocal
end

unELocal : ELocal -- ECtx LocSet Nat
unELocal = match(MkELocal -> id)

elocalNil : ELocal
elocalNil =  ectxNil locSetNull n0 MkELocal

elocalFreshNat : ELocal -- ELocal Nat
elocalFreshNat = unELocal dup dip(n1+ pnat MkELocal)

elocalUseCtx(f: ECtx a -- ECtx b) : ELocal a -- ELocal b
elocalUseCtx(f) = dip(unELocal) dip2''(f) dip(MkELocal)

elocalUseLoc(f: LocSet a -- LocSet b) : ELocal a -- ELocal b
elocalUseLoc(f) = dip(unELocal) dip'(f) dip(MkELocal)



||| Elaboration Environment
data EEnv
  MkEEnv : EWorld EFocus ELocal -- EEnv
end

unEEnv : EEnv -- EWorld EFocus ELocal
unEEnv = match(MkEEnv -> id)

eenvNil : EEnv
eenvNil = eworldNil efocusNil elocalNil MkEEnv

eenvUseWorld(f: EWorld a -- EWorld b) : EEnv a -- EEnv b
eenvUseWorld(f) = dip(unEEnv) dip2''(f) dip(MkEEnv)

eenvUseFocus(f: EFocus a -- EFocus b) : EEnv a -- EEnv b
eenvUseFocus(f) = dip(unEEnv) dip'(f) dip(MkEEnv)

eenvUseLocal(f: ELocal a -- ELocal b) : EEnv a -- EEnv b
eenvUseLocal(f) = dip(unEEnv) f dip(MkEEnv)

eenvFreshNat : EEnv -- EEnv Nat
eenvFreshNat = unit eenvUseLocal(drop elocalFreshNat)

emFreshNat : EMonad(Nat)
emFreshNat = emGet(eenvFreshNat)

emFreshName : EMonad(Name)
emFreshName = emFreshNat emMap(dip("?") nat->str <> mkName)

emGetCtx : EMonad(ECtx)
emGetCtx = unit emUse(eenvUseLocal(elocalUseCtx(drop dup)))

emGetBind : Name -- EMonad(Maybe(EBind))
emGetBind = emUse(eenvUseLocal(elocalUseCtx(ectxUseBinds(dip(dup) ebindsGet))))

emSetBind : Name EBind -- EMonad(Unit)
emSetBind = pack2 emUse(eenvUseLocal(elocalUseCtx(ectxUseBinds(unpack2 ebindsSet unit))))

emFreshType : EMonad(EType)
emFreshType = $(
  emFreshName emGetCtx
  emBind2(
    dip(dup)
    dip2(ETVar emPure)
    ectxVars none EMPlastic EBType emSetBind
    emMap2(drop)
  )
)


emFor(f: a b -- EMonad(a)) : a List(b) -- EMonad(a)
emFor(f) = lmatchL(emPure, dip(f) emPure emBind2(emFor(f)))

emForB(f: a b -- EMonad(a)) : EMonad(a) List(b) -- EMonad(a)
emForB(f) = emPure emBind2(emFor(f))

emList(f: a -- EMonad(b)) : List(a) -- EMonad(List(b))
emList(f) = dip(nil) emFor(dip(emPure) f emMap2(consR))

emFor_(f: a -- EMonad(Unit)) : List(a) -- EMonad(Unit)
emFor_(f) = dip(unit emPure) for(f emVoid2)

elabL(f: a -- EMonad(b)) : L(a) -- EMonad(b)
elabL(f) = getL f # TODO: Keep track of current location within EEnv.

elabL2(f: a b -- EMonad(c)) : a L(b) -- EMonad(c)
elabL2(f) = unL dip(swap) pack2 mkL elabL(unpack2 f)

elabL3(f: a b c -- EMonad(d)) : a b L(c) -- EMonad(d)
elabL3(f) = unL dip(rotr) pack3 mkL elabL(unpack3 f)

emGetFocus : EMonad(EFocus)
emGetFocus = unit emUse(eenvUseFocus(drop dup))

emSetFocus : EFocus -- EMonad(Unit)
emSetFocus = emUse(eenvUseFocus(nip unit))

emGetFocusModule : EMonad(EModule)
emGetFocusModule =
  emGetFocus emBind(match(
    EFNone -> "Compiler Error: emGetFocusModule: Not in module." emFail,
    EFPackage -> drop "Compiler Error: emGetFocusModule: Not in module." emFail,
    EFModule -> nip emPure,
    EFInterface -> drop nip emPure
  ))

elabLModule : L(Module) -- EMonad(Unit)
elabLImport : L(Import) -- EMonad(Unit)
elabLExport : L(Export) -- EMonad(Unit)
elabLSig : L(Sig) -- EMonad(Unit)
elabLDecl : L(Decl) -- EMonad(Unit)
elabLTypeSig : L(TypeSig) -- EMonad(Unit)
elabLDataDef : L(DataDef) -- EMonad(Unit)
elabLWordSig : L(WordSig) -- EMonad(Unit)
elabLWordDef : L(WordDef) -- EMonad(Unit)
elabLAssertion : L(Assertion) -- EMonad(Unit)

elabModule : Module -- EMonad(Unit)
elabImport : Import -- EMonad(Unit)
elabExport : Export -- EMonad(Unit)
elabSig : Sig -- EMonad(Unit)
elabDecl : Decl -- EMonad(Unit)
elabTypeSig : TypeSig -- EMonad(Unit)
elabDataDef : DataDef -- EMonad(Unit)
elabWordSig : WordSig -- EMonad(Unit)
elabWordDef : WordDef -- EMonad(Unit)
elabAssertion : Assertion -- EMonad(Unit)

elabLModule = elabL(elabModule)
elabLDecl = elabL(elabDecl)
elabLSig = elabL(elabSig)
elabLTypeSig = elabL(elabTypeSig)
elabLDataDef = elabL(elabDataDef)
elabLWordSig = elabL(elabWordSig)
elabLWordDef = elabL(elabWordDef)
elabLAssertion = elabL(elabAssertion)

elabModule = drop emUnit
elabImport = drop emUnit
elabExport = drop emUnit
elabDecl = drop emUnit
elabSig = drop emUnit
elabTypeSig = drop emUnit
elabDataDef = drop emUnit
elabWordSig = drop emUnit
elabWordDef = drop emUnit
elabAssertion = drop emUnit

runElabModule : Mod L(Module) -- Result(EError, EModule)
runElabModule = $(
  dip(efocusNilMod emSetFocus)
  elabLModule
  emGetFocusModule
  emMap3(nip nip)
  dip(eenvNil) emRun nip
)

