
import base/unit
import base/maybe
import base/result
import base/list
import base/str
import base/int
import base/nat
import base/sexp
import base/map
import base/set

import mirth/loc
import mirth/pkg
import mirth/mod
import mirth/syntax

export mirth/elab
  type Result(a,b)
  type EEnv
  type EError
  type EMonad(t)

  emRun : EEnv EMonad(t) -- EEnv Result(EError,t)
  emFail : Str -- EMonad(a)
  emPure : a -- EMonad(a)
  emPure2 : a b -- EMonad(a) EMonad(b)
  emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
  emMap(f: a -- b) : EMonad(a) -- EMonad(b)
  emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
  emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
  emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
  emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
  emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
  emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)

  type EModule

  runElabModule : Mod L(Module) -- Result(EError, EModule)
  eerror->str : EError -- Str
  emodule->str : EModule -- Str

end

||| Elaborator error.
data EError
  MkEError : Str -- EError
end

unEError : EError -- Str
unEError = match(MkEError -> id)

eerror->str : EError -- Str
eerror->str = unEError

||| Elaboration monad.
data EMonad(t)
  MkEMonad(f: EEnv m -- EEnv Result(EError, t)) : m -- EMonad(t)
end

emUse(f: EEnv a -- EEnv b) : a -- EMonad(b)
emUse(f) = MkEMonad(f ok)

emGet(f: EEnv -- EEnv b) : EMonad(b)
emGet(f) = unit emUse(drop f)

emPut(f: EEnv t -- EEnv) : t -- EMonad(Unit)
emPut(f) = emUse(f unit)

emRun : EEnv EMonad(t) -- EEnv Result(EError, t)
emRun = match(MkEMonad(f) -> f)

emPure : a -- EMonad(a)
emPure = MkEMonad(ok)

emFail : Str -- EMonad(a)
emFail = MkEMonad(MkEError err)

emPure2 : a b -- EMonad(a) EMonad(b)
emPure2 = dip(emPure) emPure

emPure3 : a b c -- EMonad(a) EMonad(b) EMonad(c)
emPure3 = dip(emPure2) emPure

emMap(f: a -- b) : EMonad(a) -- EMonad(b)
emMap(f) = MkEMonad(emRun rmap(f))

emMap2(f: a b -- c) : EMonad(a) EMonad(b) -- EMonad(c)
emMap2(f) =
  pack2 MkEMonad(
    unpack2 dip(emRun) swap
    result(nip err,
      dip(emRun) swap
      result(nip err, f ok)
    )
  )

emMap3(f: a b c -- d) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emMap3(f) = emMap2(pack2) emMap2(unpack2 f)

emMap4(f: a b c d -- e) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emMap4(f) = emMap2(pack2) emMap3(unpack2 f)

emBind(f: a -- EMonad(b)) : EMonad(a) -- EMonad(b)
emBind(f) = MkEMonad(emRun result(err, f emRun))

emBind2(f: a b -- EMonad(c)) : EMonad(a) EMonad(b) -- EMonad(c)
emBind2(f) = emMap2(pack2) emBind(unpack2 f)

emBind3(f: a b c -- EMonad(d)) : EMonad(a) EMonad(b) EMonad(c) -- EMonad(d)
emBind3(f) = emMap3(pack3) emBind(unpack3 f)

emBind4(f: a b c d -- EMonad(e)) : EMonad(a) EMonad(b) EMonad(c) EMonad(d) -- EMonad(e)
emBind4(f) = emMap4(pack4) emBind(unpack4 f)

emUnit : EMonad(Unit)
emUnit = unit emPure

emVoid : EMonad(a) -- EMonad(Unit)
emVoid = emMap(drop unit)

emVoid2 : EMonad(a) EMonad(b) -- EMonad(Unit)
emVoid2 = emMap2(drop2 unit)

###############
# Elaboration #
###############


||| A type definition.
data EDefType
  MkEDefType : EDefType
end

unEDefType : EDefType --
unEDefType = match(MkEDefType -> id)

edeftype->sexp : EDefType -- Sexp
edeftype->sexp = unEDefType "type" sexpAtom


||| A word definition.
data EDefWord
  MkEDefWord : EDefWord
end

unEDefWord : EDefWord --
unEDefWord = match(MkEDefWord -> id)

edefword->sexp : EDefWord -- Sexp
edefword->sexp = unEDefWord "word" sexpAtom


||| A definition.
data EDef
  EDType : EDefType -- EDef
  EDWord : EDefWord -- EDef
end

edef->sexp : EDef -- Sexp
edef->sexp =
  match(
    EDType -> edeftype->sexp,
    EDWord -> edefword->sexp
  )


||| A set of definitions in a single scope.
data EDefs
  MkEDefs : Map(Name, EDef) -- EDefs
end

unEDefs : EDefs -- Map(Name, EDef)
unEDefs = match(MkEDefs -> id)

edefsNil : EDefs
edefsNil = mapNil MkEDefs

edefsGet : EDefs Name -- Maybe(EDef)
edefsGet = dip(unEDefs) mapGet

edefsSet : EDefs Name EDef -- EDefs
edefsSet = dip2(unEDefs) mapSet MkEDefs

edefs->sexp : EDefs -- Sexp
edefs->sexp = unEDefs map->sexp(name->sexp, edef->sexp)


||| A single interface.
data EInterface
  MkEInterface : Pkg Interface EDefs -- EInterface
end

unEInterface : EInterface -- Pkg Interface EDefs
unEInterface = match(MkEInterface -> id)

einterface->sexp : EInterface -- Sexp
einterface->sexp = $(
  unEInterface
  dip3("interface" sexpAtom lpure)
  dip2(pkg->sexp cons)
  dip(interface->sexp cons)
  edefs->sexp cons
  sexpList
)


||| A module's imports, i.e. a set of interfaces.
data EImports
  MkEImports : Set(Interface) -- EImports
end

unEImports : EImports -- Set(Interface)
unEImports = match(MkEImports -> id)

eimportsNil : EImports
eimportsNil = setNil MkEImports

eimports->sexp : EImports -- Sexp
eimports->sexp = unEImports set->sexp(interface->sexp)


||| A module's exports, i.e. a map of interface definitions.
data EExports
  MkEExports : Map(Interface, EInterface) -- EExports
end

unEExports : EExports -- Map(Interface, EInterface)
unEExports = match(MkEExports -> id)

eexportsNil : EExports
eexportsNil = mapNil MkEExports

eexports->sexp : EExports -- Sexp
eexports->sexp = unEExports map->sexp(interface->sexp, einterface->sexp)


||| A single Mirth module.
data EModule
  MkEModule : Mod EImports EExports EDefs -- EModule
end

unEModule : EModule -- Mod EImports EExports EDefs
unEModule = match(MkEModule -> id)

emoduleNil : Mod -- EModule
emoduleNil = eimportsNil eexportsNil edefsNil MkEModule

emodule->sexp : EModule -- Sexp
emodule->sexp = $(
  unEModule
  dip4("module" sexpAtom lpure)
  dip3(mod->sexp cons)
  dip2(eimports->sexp cons)
  dip(eexports->sexp cons)
  edefs->sexp cons
  sexpList
)

emodule->str : EModule -- Str
emodule->str = emodule->sexp sexp->str


||| A Mirth package, i.e. a collection of modules and interfaces.
data EPackage
  MkEPackage : Pkg EExports Map(Mod, EModule) -- EPackage
end

unEPackage : EPackage -- Pkg EExports Map(Mod, EModule)
unEPackage = match(MkEPackage -> id)

epackageNil : Pkg -- EPackage
epackageNil = eexportsNil mapNil MkEPackage

epackage->sexp : EPackage -- Sexp
epackage->sexp = $(
  unEPackage
  dip3("package" sexpAtom lpure)
  dip2(pkg->sexp cons)
  dip(eexports->sexp cons)
  map->sexp(mod->sexp, emodule->sexp) cons
  sexpList
)


||| Elaboration World -- The collection of loaded packages and modules.
||| This should be unchanged during module elaboration.
data EWorld
  MkEWorld : Map(Pkg, EPackage) -- EWorld
end

unEWorld : EWorld -- Map(Pkg, EPackage)
unEWorld = match(MkEWorld -> id)

eworldNil : EWorld
eworldNil = mapNil MkEWorld


||| Elaboration Focus -- The current package/module/interface being
||| elaborated. This should be unchanged during expression elaboration.
data EFocus
  EFNone : EFocus
  EFPackage : EPackage -- EFocus
  EFModule : EPackage EModule -- EFocus
  EFInterface : EPackage EModule EInterface -- EFocus
end

efocusNil : EFocus
efocusNil = EFNone


||| Local Scope
data ECtx
  ECtxNil : ECtx
end

ectxNil : ECtx
ectxNil = ECtxNil


||| Environment -- The current scope and metavariables.
data ELocal
  MkELocal : ECtx LocSet Nat -- ELocal
end

unELocal : ELocal -- ECtx LocSet Nat
unELocal = match(MkELocal -> id)

elocalNil : ELocal
elocalNil =  ectxNil locSetNull n0 MkELocal

elocalFreshNat : ELocal -- ELocal Nat
elocalFreshNat = unELocal dup dip(n1+ pnat MkELocal)


||| Elaboration Environment
data EEnv
  MkEEnv : EWorld EFocus ELocal -- EEnv
end

unEEnv : EEnv -- EWorld EFocus ELocal
unEEnv = match(MkEEnv -> id)

eenvNil : EEnv
eenvNil = eworldNil efocusNil elocalNil MkEEnv

eenvUseWorld(f: EWorld a -- EWorld b) : EEnv a -- EEnv b
eenvUseWorld(f) = dip(unEEnv) dip2''(f) dip(MkEEnv)

eenvUseFocus(f: EFocus a -- EFocus b) : EEnv a -- EEnv b
eenvUseFocus(f) = dip(unEEnv) dip'(f) dip(MkEEnv)

eenvUseLocal(f: ELocal a -- ELocal b) : EEnv a -- EEnv b
eenvUseLocal(f) = dip(unEEnv) f dip(MkEEnv)

eenvFreshNat : EEnv -- EEnv Nat
eenvFreshNat = unit eenvUseLocal(drop elocalFreshNat)

emFreshNat : EMonad(Nat)
emFreshNat = emGet(eenvFreshNat)


emFor(f: a b -- EMonad(a)) : a List(b) -- EMonad(a)
emFor(f) = lmatchL(emPure, dip(f) emPure emBind2(emFor(f)))

emForB(f: a b -- EMonad(a)) : EMonad(a) List(b) -- EMonad(a)
emForB(f) = emPure emBind2(emFor(f))

emList(f: a -- EMonad(b)) : List(a) -- EMonad(List(b))
emList(f) = dip(nil) emFor(dip(emPure) f emMap2(consR))

emFor_(f: a -- EMonad(Unit)) : List(a) -- EMonad(Unit)
emFor_(f) = dip(unit emPure) for(f emVoid2)

elabL(f: a -- EMonad(b)) : L(a) -- EMonad(b)
elabL(f) = getL f # TODO: Keep track of current location within EEnv.

elabL2(f: a b -- EMonad(c)) : a L(b) -- EMonad(c)
elabL2(f) = unL dip(swap) pack2 mkL elabL(unpack2 f)

elabL3(f: a b c -- EMonad(d)) : a b L(c) -- EMonad(d)
elabL3(f) = unL dip(rotr) pack3 mkL elabL(unpack3 f)

emGetFocus : EMonad(EFocus)
emGetFocus = unit emUse(eenvUseFocus(drop dup))

emSetFocus : EFocus -- EMonad(Unit)
emSetFocus = emUse(eenvUseFocus(nip unit))

emGetFocusModule : EMonad(EModule)
emGetFocusModule =
  emGetFocus emBind(match(
    EFNone -> "Compiler Error: emGetFocusModule: Not in module." emFail,
    EFPackage -> drop "Compiler Error: emGetFocusModule: Not in module." emFail,
    EFModule -> nip emPure,
    EFInterface -> drop nip emPure
  ))

elabLModule : L(Module) -- EMonad(Unit)
elabLImport : L(Import) -- EMonad(Unit)
elabLExport : L(Export) -- EMonad(Unit)
elabLSig : L(Sig) -- EMonad(Unit)
elabLDecl : L(Decl) -- EMonad(Unit)
elabLTypeSig : L(TypeSig) -- EMonad(Unit)
elabLDataDef : L(DataDef) -- EMonad(Unit)
elabLWordSig : L(WordSig) -- EMonad(Unit)
elabLWordDef : L(WordDef) -- EMonad(Unit)
elabLAssertion : L(Assertion) -- EMonad(Unit)

elabModule : Module -- EMonad(Unit)
elabImport : Import -- EMonad(Unit)
elabExport : Export -- EMonad(Unit)
elabSig : Sig -- EMonad(Unit)
elabDecl : Decl -- EMonad(Unit)
elabTypeSig : TypeSig -- EMonad(Unit)
elabDataDef : DataDef -- EMonad(Unit)
elabWordSig : WordSig -- EMonad(Unit)
elabWordDef : WordDef -- EMonad(Unit)
elabAssertion : Assertion -- EMonad(Unit)

elabLModule = elabL(elabModule)
elabLDecl = elabL(elabDecl)
elabLSig = elabL(elabSig)
elabLTypeSig = elabL(elabTypeSig)
elabLDataDef = elabL(elabDataDef)
elabLWordSig = elabL(elabWordSig)
elabLWordDef = elabL(elabWordDef)
elabLAssertion = elabL(elabAssertion)

elabModule = drop emUnit
elabImport = drop emUnit
elabExport = drop emUnit
elabDecl = drop emUnit
elabSig = drop emUnit
elabTypeSig = drop emUnit
elabDataDef = drop emUnit
elabWordSig = drop emUnit
elabWordDef = drop emUnit
elabAssertion = drop emUnit

||| Create a focus out of a Pkg.
pkg->efocus : Pkg -- EFocus
pkg->efocus = epackageNil EFPackage

||| Create a focus out of a Mod, for testing purposes.
mod->efocus : Mod -- EFocus
mod->efocus = dup dip(mod->pkg epackageNil) emoduleNil EFModule

runElabModule : Mod L(Module) -- Result(EError, EModule)
runElabModule = $(
  dip(mod->efocus emSetFocus)
  elabLModule
  emGetFocusModule
  emMap3(dip(drop2))
  dip(eenvNil) emRun nip
)

