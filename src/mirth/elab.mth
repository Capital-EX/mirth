import base/str
import base/list
import base/map
import base/set
import base/maybe
import base/result

import mirth/mod
import mirth/loc
import mirth/syntax
import mirth/core

export mirth/elab
  type Map(k,v)
  type Mod
  type Module
  type Interface
  type CoreModule
  type CoreInterface

  type ElabError

  elabError->str : ElabError -- Str
  elabPackage : Map(Mod, Module) -- Map(Interface, CoreInterface) Map(Mod, CoreModule) List(ElabError)
end

data ElabError
  mkElabError : L(Str) -- ElabError
end

elabError->str =
  match( mkElabError ->
    unL dip(locSet->str) <>
  )

elabType : CoreEnv CoreCtx L(Type) -- CoreEnv CoreCtx Result(ElabError, CoreType)

addErrorLoc : LocSet Result(CoreError, t) -- Result(ElabError, t)
addErrorLoc =
  result(
    coreError->str mkL mkElabError err,
    nip ok
  )

elabParam : CoreEnv CoreCtx L(Param) -- CoreEnv Result(ElabError, CoreCtx)
elabParam =
  unL dip(rotr) cond(

    dup paramParams getL unParams nil? not nip ->
      nip paramParams unL drop
      "Higher-order params not supported." mkL
      mkElabError dip2(drop) err,

    dup2 paramName getL mkCoreVar coreCtxHasPositional? dip(drop2) ->
      nip paramName unL
      name->str dip("Repeated positional parameter ") <> mkL
      mkElabError dip2(drop) err,

   dup paramName getL isStarVarName ->
     dup par(paramName, paramType)
     maybe(
       getL mkCoreVar coreKindStack coreCtxCons dip(swap) addErrorLoc,
       drop unL name->str dip("Invalid name for typed parameter ") <> mkL
       mkElabError err nip dip2(drop)
     ),

  dup paramName getL isVarName ->
    dup par(paramName getL mkCoreVar, paramType)
    maybe(
      coreKindType coreCtxCons dip(swap) addErrorLoc,
      swap dip(elabType) swap result(
        dip(drop2) dip2(drop) err,
        coreKindWord coreCtxCons dip(swap) addErrorLoc
      )
    ),

    nip paramName unL name->str
    dip("Invalid name for parameter ") <>
    mkL mkElabError dip2(drop) err
  )

elabParams : CoreEnv L(Params) -- CoreEnv Result(ElabError, CoreCtx)
elabParams = $(
  dip(coreCtxNil ok) getL unParams
  for(
    swap result(
      nip err,
      swap elabParam
    )
  )
)

TODO(x: Str) : *a -- *b
TODO(x) = "not yet implemented: " x <> _prim_unsafe_panic

badCoreDef : CoreDef
badCoreDef = setNil coreDefError

elabTypeSig : CoreEnv L(TypeSig) -- CoreEnv List(ElabError)
elabTypeSig = $(
  unL dip(swap) dup par(typeSigParams, typeSigName) unL mkCoreSym dip(rotr)
  dip(elabParams) swap result(
    # params are bad.
    dip3(drop2) dip(badCoreDef coreEnvSet) nil snoc,
    dip?(coreEnvGet?) maybe(
      dip(setNil) coreDefTypeSig coreDefType coreEnvSet dip(drop2) nil,
      TODO("elab type sig already exists case")
    )
  )
)

elabDataDef : CoreEnv L(DataDef) -- CoreEnv List(ElabError)
elabWordSig : CoreEnv L(WordSig) -- CoreEnv List(ElabError)
elabWordDef : CoreEnv L(WordDef) -- CoreEnv List(ElabError)
elabAssertion : CoreEnv L(Assertion) -- CoreEnv List(ElabError)

elabSig : CoreEnv L(Sig) -- CoreEnv List(ElabError)
elabSig =
  getL matchSig(
    elabTypeSig,
    elabWordSig,
    elabAssertion
  )

elabDecl : CoreEnv L(Decl) -- CoreEnv List(ElabError)
elabDecl =
  getL matchDecl(
    elabTypeSig,
    elabDataDef,
    elabWordSig,
    elabWordDef,
    elabAssertion
  )

elabInterfaces : Map(Mod, Module) -- Map(Interface, CoreInterface) List(ElabError)
elabInterfaces = $(
  dip(mapNil nil)
  mapFor(
    nip moduleExports getL
    for(
      getL
      save(exportInterface getL)
      exportSigs
      dip(coreEnvNil)
      for(
        elabSig
        rotr dip2(++)
      )
      dip(dup) mkCoreInterface
      rotl dip(mapSet)
    )
  )
)

elabModule : Map(Interface, CoreInterface) Mod Module -- CoreModule List(ElabError)
elabModule = $(
  swap coreModuleNil nil
  dip2(drop2)
)

elabPackage : Map(Mod, Module) -- Map(Interface, CoreInterface) Map(Mod, CoreModule) List(ElabError)
elabPackage = $(
  dup elabInterfaces
  rotr swap dip(mapNil)
  mapFor(
    dip2(over) dip(tuck)
    elabModule dip(mapSet)
    rotr dip2(++)
  )
  rotl
)

