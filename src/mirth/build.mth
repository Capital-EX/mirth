import base/io
import base/str
import base/unit
import base/list
import base/path
import base/panic
import base/maybe
import base/result
import mirth/types/pkg
import mirth/types/mod
import mirth/token
import mirth/lexer

export mirth/build
  type +IO
  type Path
  buildPath : Path -- Int +IO
end

findMods : Pkg -- List(Mod) +IO
findMods = $(
  dup pkg->path listfiles
  filter(pathHasExtension?("mth"))
  formap(dip(dup) pkgMod) nip
)

buildPkgMods : Maybe(Pkg) List(Mod) -- Int +IO
buildPkgMods = $(
  dip(maybe("no pkg", pkg->str) print)
  cond(
    nil? -> drop "No modules found." print 1,
    no_panic_11(headL)
    dup mod->str "Opening " swap <> trace
    dup mod->path read
    tokenize result(
      lexerError->str print 1,
      for(ltoken->str print) 0
    )
  )
)

buildPkg : Pkg -- Int +IO
buildPkg = dup dip(some) findMods buildPkgMods

buildMod : Mod -- Int +IO
buildMod = dip(none) nil snoc buildPkgMods

buildPath : Path -- Int +IO
buildPath = $(
  cond(
    dup isfile -> pathMod buildMod,
    dup isdir  -> pathPkg buildPkg,
    "mirth: Path does not exist: " swap path->str <> trace 1
  )
)


