
import base/nat

export base/list
  type Nat
  nil    : List(t)
  cat    : List(t) List(t) -- List(t)
  ++     : List(t) List(t) -- List(t)
  cons   : List(t) t -- List(t)
  snoc   : t List(t) -- List(t)

  len? : List(t) -- List(t) Nat
  len  : List(t) -- Nat

  nil?    : List(t) -- List(t) Bool

  map(f: a -- b) : List(a) -- List(b)
  for(f: *a b -- *a) : *a List(b) -- *a
  break : List(t) Nat -- List(t) List(t)
  flatten : List(List(t)) -- List(t)

  lpure : t -- List(t)
  lbind (f: a -- List(b)) : List(a) -- List(b)

  uncons : List(t) -- List(t) t   # panic on failure
  unsnoc : List(t) -- t List(t)   # panic on failure

end


nil     = _prim_list_nil
cat     = _prim_list_cat
cons    = _prim_list_cons
len     = _prim_list_len znat
map(f) = _prim_list_map(f)
for(f) = _prim_list_for(f)
break  = nint _prim_list_break

++    = cat
snoc  = dip(dip(nil) cons) cat
len?  = dup len
nil?  = len? n0 n=

flatten = dip(nil) for(cat)

lpure = dip(nil) cons
lbind(f) = map(f) flatten

cat len == both(len) n+
break cat == drop

map(id) == id
lbind(id) == flatten

uncons = nil? if("uncons on empty list" _prim_unsafe_panic,
  len? n1- znat break 0 _prim_list_at)
unsnoc = nil? if("unsnoc on empty list" _prim_unsafe_panic,
  n1 break dip(0 _prim_list_at))



